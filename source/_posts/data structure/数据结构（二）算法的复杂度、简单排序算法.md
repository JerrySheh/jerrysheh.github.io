---
title: 数据结构（二）算法的复杂度、简单排序算法
categories: 数据结构和算法
tags: 数据结构和算法
abbrlink: 7c5cf5e1
date: 2017-12-06 12:58:29
---

# 前言：算法的复杂度

在讨论数据结构和算法时，我们通常用算法的复杂度来描述一个算法的好坏，复杂度包括：**时间复杂度** 和 **空间复杂度**。计算机本质上是一个状态机，内存里的数据构成了当前的状态，CPU利用当前的状态计算出下一个状态。所谓的空间复杂度就是为了支持你的计算所必需存储的状态最多有多少，所谓时间复杂度就是从初始状态到达最终状态中间需要多少步！

<!-- more -->

## 时间复杂度

算法的时间复杂度，也就是算法的时间量度，记作：`T(n) = O(f(n))`。它表示随问题规模 n 的增大，算法执行时间的增长率和 f(n) 的增长率相同，称为算法的渐近时间复杂度，**简称为时间复杂度**。其中 f(n) 是规模 n 的某个函数。

### 如何推导时间复杂度

1. 用常数 1 取代运行时间中的所有加法常数。
2. 在修改后的运行次数函数中，只保留最高阶项。
3. 如果最高阶项存在，且不是 1 ，则去除与这个项相乘的常数。

例如:

```c
int sum = 0, n = 100;   // 执行 1 次
sum = (1 + n) * n / 2;  // 执行 1 次
printf("%d", sum);      // 执行 1 次
```

这个算法的运行次数函数是 `f(n) = 3`。根据推导规则，第一步把常数项 3 改为 1。第二步保留最高阶项，它没有最高阶项，所以这个算法的时间复杂度为 `T(n) = O(1)`。

#### 常数阶

当 n = 1 时，算法执行次数为 3， 当 n = 100 时，算法的执行次数还是 3，所以我们可以看出这个算法的执行次数与 n 的规模没关系。我们把这种与问题的大小（n 的大小）无关，执行时间恒定的算法，叫作常数阶。

#### 线性阶

下面这段代码的时间复杂度为 `T(n) = O(n)`，因为循环体中的代码必须要执行 n 次。

```java
for (i = 0; i < n; i++) {
    /* 时间复杂度为 O(1) 的程序步骤序列 */
}
```

#### 对数阶

```java
int count = 1;
while (count < n) {
    count = count * 2;
    /* 时间复杂度为 O(1) 的程序步骤序列 */
}
```

由于每次 count 乘以 2 以后，就越来越接近于 n，也就是说有多少个 2 相乘后大于 n，则会退出循环。由` 2^x = n` 得到 ` x = log2n`。所以这个算法的时间复杂度为 `T(n) = O(logn)`。

#### 平方阶

```java
// 例1
int i, j;
for (i = 0; i < n; i++) {
    for (j = 0; j < n; j++) {
        /* 时间复杂度为 O(1) 的程序步骤序列 */
    }
}

// 例2
int i, j， m;
for (i = 0; i < m; i++) {
    for (j = 0; j < n; j++) {
        /* 时间复杂度为 O(1) 的程序步骤序列 */
    }
}
```

在 例1 中内循环时间复杂度为`O(n)`，而对于外层的循环，不过是这个内循环再循环 n 次。所以这段代码的时间复杂度为 `O(n^2)`。

在 例2 中，时间复杂度就变为 O(m^n)

### 常见的时间复杂度耗费时间

从小到大依次是：

O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)

## 空间复杂度

算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式：

```
S(n) = O(f(n))
```

其中 n 为问题的规模，`f(n)`为语句关于 n 所占存储空间的函数。

- 参考：[程序猿必修课之数据结构（二）算法和算法的复杂度](https://www.jianshu.com/p/d72d4c9e90c6)

##  复杂度分析的主要方法

1. **迭代**：级数求和
2. **递归**：递归跟踪 + 递推方程

猜测 + 验证

---

# 一、选择排序（Selection Sort）

## 选择排序介绍

选择排序是一种最简单的排序算法，它的算法步骤如下：
1. 找到数组中最小的元素
2. 将它和数组的第一个元素交换位置（如果相同，也交换）
3. 在剩下的元素中找到最小的元素
4. 将它和数组的第二个元素交换位置
5. 重复。。

选择排序交换的总次数为N，算法的效率取决于比较的次数。

特点：

- 运行时间和输入无关、移动数据是最少的
- 选择排序是不稳定的排序方法
- 对于长度为 N 的数组，选择排序需要大约 N²/2次比较和 N 次交换
- 时间复杂度 O(n^2)

## 算法2.1 选择排序

```java
public static void selectSort(int[] arr){

    int size = arr.length;

    for (int i = 0; i < size; i++) {
        int min = i;
        // 第二个for循环找出最小元素
        for (int j = i; j < size; j++) {
            if (arr[j] < arr[min]) min = j;
        }
        Swap.swap(arr, min, i);
    }

}
```

---


# 二、插入排序（Insertion Sort）

## 插入排序介绍

插入排序，将数插入到其他已经有序的数中的适当位置。为了给要插入的数腾出空间，我们需要将其余所有元素在插入之前都向右移动一位。

插入排序所需的时间取决于输入中元素的初始顺序。(原始数据越接近有序，越快)

命题：对于随机排列的长度为 N 且主键不重复的数组，平均情况下插入排序需要约 N²/4 次比较以及 N²/4 次交换。最坏情况下需要 约 N²/2 次比较以及 N²/2 次交换，最好情况下需要 N-1 次比较 和 0 次交换。

时间复杂度：O(n^2)

## 算法2.2 插入排序

```java
/**
 * 原理：插入排序，将数插入到其他已经有序的数中的适当位置
 * 思路：从 a[0] 开始，a[0] 已经是第一个，所以不用动
 *       a[1] 与 a[0] 比较 -> 得出顺序
 *       a[2] 与 a[1] a[0] 比较 -> a[2] 先与 a[1] 比较 ，如果 a[2] 比 a[1] 小，则交换， 然后 a[1] 与 a[0] 比较
 *       a[3] 与 a[2] a[1] a[0] 比较 -> 插入适当位置
 *       ...
 */
private static void insertSort(int[] arr){
    for (int i = 1; i < arr.length; i++) {
        for (int j = i; j > 0 && arr[j] < arr[j-1]; j--) {
            Swap.swap(arr, j, j-1);
        }
    }
}
```

 ---

# 三、希尔排序（Shell Sort）

## 希尔排序介绍

在插入排序和选择排序中，由于它们只能交换相邻的元素，如果有位于数组起始的大元素，则需要多次遍历才能交换到队尾，很不划算。希尔排序以更大的间隔来比较和交换元素，这样，大元素在交换的时候，可以向右移动不止一个位置。

希尔排序只需要在插入排序的代码中将移动的元素距离由1改为h即可。

希尔排序依赖于间隔(step)的选取。


## 算法2.3 希尔排序

```java
public class Shell {
    public static void sort(Comparable[] a){
        int N = a.length;
        int h = 1;
        while(h < N/3) h = 3*h + 1;  // 1,4,13,40,121,364,1093...

        //将数组变为h有序
        while (h >= 1){
            //将a[i] 插入到 a[i-h]、a[i-2h]、a[i-3h]...之中
            for (int i = h; i < N ; i++) {
                for (int j = i; j > h && less(a[j],a[j-h]); j-=h) {
                    exch(a, j, j-h);
                }
            }
            h = h/3;
        }
    }
}
```

---

# 四、冒泡排序

比较相邻元素，大的放右边

要点：第一躺结束后，最右元素一定是最大的，因此第二趟最右元素不参与，即 size - i - 1

时间复杂度：O(n^2)

```java
public static void bubbleSort(int[] arr){

    int size = arr.length;

    for (int i = 0; i < size; i++) {
        // 第一躺结束后，最右元素一定是最大的，因此第二趟最右元素不参与，即 size - i - 1
        for (int j = 0; j < size - i - 1; j++) {
            if (arr[j] > arr[j+1]) Swap.swap(arr, j, j+1);
        }
    }
}
```
