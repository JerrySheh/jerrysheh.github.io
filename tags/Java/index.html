<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>标签: Java - J.e</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="J.e"><meta name="msapplication-TileImage" content="/images/blog/ava.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="J.e"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="车顶上绑着飞机发动机的小车也许真的能开，只要你不尝试急转弯"><meta property="og:type" content="blog"><meta property="og:title" content="J.e"><meta property="og:url" content="https://jerrysheh.com/"><meta property="og:site_name" content="J.e"><meta property="og:description" content="车顶上绑着飞机发动机的小车也许真的能开，只要你不尝试急转弯"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://jerrysheh.com/img/og_image.png"><meta property="article:author" content="Jerry Sheh"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://jerrysheh.com"},"headline":"J.e","image":["https://jerrysheh.com/img/og_image.png"],"author":{"@type":"Person","name":"Jerry Sheh"},"publisher":{"@type":"Organization","name":"J.e","logo":{"@type":"ImageObject","url":"https://jerrysheh.com/images/blog/logo.png"}},"description":"车顶上绑着飞机发动机的小车也许真的能开，只要你不尝试急转弯"}</script><link rel="icon" href="/images/blog/ava.png"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.13.1/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><!--!--><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/images/blog/logo.png" alt="J.e" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">时间线</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/about">关于</a><a class="navbar-item" href="/sentences">醍醐灌顶</a><a class="navbar-item" href="/anpu">Anpu</a></div><div class="navbar-end"><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/tags">标签</a></li><li class="is-active"><a href="#" aria-current="page">Java</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-03-28T12:25:00.000Z" title="2021-3-28 20:25:00">2021-03-28</time>发表</span><span class="level-item"><time dateTime="2021-03-29T14:54:46.663Z" title="2021-3-29 22:54:46">2021-03-29</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a><span> / </span><a class="link-muted" href="/categories/Java/JDBC/">JDBC</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/post/720e88bc.html">记一次Spring JDBC内存泄漏引起的线上事故</a></h1><div class="content"><h2 id="问题再现"><a href="#问题再现" class="headerlink" title="问题再现"></a>问题再现</h2><p>最近在维护一个基于 Spring Boot 的数据同步系统。项目使用 druid 连接池，配置动态数据源连接了 16 个数据库，主要用于跑任务处理跨库数据同步。其中的某个任务，在线上环境一直稳定运行，前几天任务又一次执行时，突然收到任务报错的邮件告警。</p></div><a class="article-more button is-small is-size-7" href="/post/720e88bc.html#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-03-02T12:43:33.477Z" title="2021-3-2 20:43:33">2021-03-02</time>发表</span><span class="level-item"><time dateTime="2021-03-02T14:11:13.607Z" title="2021-3-2 22:11:13">2021-03-02</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a><span> / </span><a class="link-muted" href="/categories/Java/JDBC/">JDBC</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/post/7969a482.html">MyBatis大批量数据处理</a></h1><div class="content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近项目里需要跨数据库同步大批量数据（百万到千万级别），以前都是用 JDBC 来实现。在 JDBC 里，我们能灵活地使用流查询来批次摄取处理，避免OOM，但 JDBC 这玩意儿写多了，谁都会嫌它既啰嗦又繁琐（但性能真香）。于是这次决定用 Springboot + Mybatis 框架来试试。因为涉及到多个数据源和不同的数据库产品（Oracle、PostgreSQL、MySQL），所以在项目里使用了动态数据源。</p>
<p>关于 Springboot 多数据源方案，我参考过最好的文章为下面的3连载，推荐一看。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://mianshenglee.github.io/2020/01/13/multi-datasource-1.html">搞定SpringBoot多数据源(1)：多套源策略</a></li>
<li><a target="_blank" rel="noopener" href="https://mianshenglee.github.io/2020/01/16/multi-datasource-2.html">搞定SpringBoot多数据源(2)：动态数据源</a></li>
<li><a target="_blank" rel="noopener" href="https://mianshenglee.github.io/2020/01/21/multi-datasource-3.html">搞定SpringBoot多数据源(3)：参数化变更源</a></li>
</ul>
<p>至于使用 Mybatis 做大批量数据读取和插入，先前也是阅读了大量的参考资料和文档。总体思想跟 JDBC 是一致的，即：<strong>流式查询、批量插入</strong>。但在讲 Mybatis 之前，先回顾一下 JDBC 时代是怎么做的吧。</p></div><a class="article-more button is-small is-size-7" href="/post/7969a482.html#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-04-08T14:54:55.000Z" title="2020-4-8 22:54:55">2020-04-08</time>发表</span><span class="level-item"><time dateTime="2020-04-11T15:14:34.422Z" title="2020-4-11 23:14:34">2020-04-11</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a><span> / </span><a class="link-muted" href="/categories/Java/Concurrent/">Concurrent</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/post/eecbf398.html">Java并发编程之AQS</a></h1><div class="content"><h1 id="什么是-AQS"><a href="#什么是-AQS" class="headerlink" title="什么是 AQS"></a>什么是 AQS</h1><p><a href="../post/a23f9c20.html">同步工具类</a> 也叫同步器（Synchronizer）。在使用同步器时，我们发现不同的同步器存在许多共同点，例如 ReentrantLock 和 Semaphore 都支持每次允许一定数量线程通过/等待/取消，也都支持让等待线程执行公平或非公平的队列操作等。</p>
<p>事实上，很多同步工具类在实现时都使用了共同的基类，这就是 <code>AbstractQueuedSynchronizer（AQS），抽象队列同步器</code>。</p></div><a class="article-more button is-small is-size-7" href="/post/eecbf398.html#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-04-06T11:08:54.000Z" title="2020-4-6 19:08:54">2020-04-06</time>发表</span><span class="level-item"><time dateTime="2020-04-19T08:56:25.236Z" title="2020-4-19 16:56:25">2020-04-19</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a><span> / </span><a class="link-muted" href="/categories/Java/Concurrent/">Concurrent</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/post/959bfd05.html">Java并发编程之对象共享</a></h1><div class="content"><h1 id="对象数据共享"><a href="#对象数据共享" class="headerlink" title="对象数据共享"></a>对象数据共享</h1><p>要实现多个线程之间的数据共享，需要考虑两个问题：</p>
<ul>
<li><strong>通信</strong>：通信是指消息在两条线程之间传递</li>
<li><strong>同步</strong>：既然要传递消息，那 <code>接收线程</code> 和 <code>发送线程</code> 之间必须要有个先后关系。此时就需要用到同步，即控制多条线程之间的执行次序。</li>
</ul></div><a class="article-more button is-small is-size-7" href="/post/959bfd05.html#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-03-14T13:57:26.000Z" title="2020-3-14 21:57:26">2020-03-14</time>发表</span><span class="level-item"><time dateTime="2020-03-14T15:04:31.932Z" title="2020-3-14 23:04:31">2020-03-14</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a><span> / </span><a class="link-muted" href="/categories/Java/JDBC/">JDBC</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/post/f215e4e1.html">JDBC + MySQL 如何正确地批量删除</a></h1><div class="content"><h1 id="问题的来源"><a href="#问题的来源" class="headerlink" title="问题的来源"></a>问题的来源</h1><p>一张2亿数据的 MySQL InnoDB大表，现要对 <code>c_date</code> 时间字段的的某时间区间内，将 <code>client_name</code> 为 <code>null</code> 的数据进行删除。<code>c_date</code> 已建索引。</p>
<p><img src="../../../../images/database/jdbc_delete_data.png"></p></div><a class="article-more button is-small is-size-7" href="/post/f215e4e1.html#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-11-29T11:50:38.000Z" title="2019-11-29 19:50:38">2019-11-29</time>发表</span><span class="level-item"><time dateTime="2020-03-06T15:20:05.290Z" title="2020-3-6 23:20:05">2020-03-06</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a><span> / </span><a class="link-muted" href="/categories/Java/Effective-Java/">Effective Java</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/post/4e34dae4.html">Effective Java（九）异常</a></h1><div class="content"><h1 id="Item-69-异常只用于异常"><a href="#Item-69-异常只用于异常" class="headerlink" title="Item 69 异常只用于异常"></a>Item 69 异常只用于异常</h1><p>异常只用于异常的情况，不要用 <code>try-catch</code> 捕获 <code>ArrayIndexOutOfBoundsException </code> 并且不做任何处理这种方式来跳出数组遍历。为什么不用 <code>for-each</code> 循环呢？</p>
<p>设计良好的 API 不应该强迫它的客户端为了正常的控制流程而使用异常。</p></div><a class="article-more button is-small is-size-7" href="/post/4e34dae4.html#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-11-27T10:50:18.000Z" title="2019-11-27 18:50:18">2019-11-27</time>发表</span><span class="level-item"><time dateTime="2020-07-05T04:06:52.285Z" title="2020-7-5 12:06:52">2020-07-05</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java-Web/">Java Web</a><span> / </span><a class="link-muted" href="/categories/Java-Web/Spring/">Spring</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/post/a0972c39.html">Spring（九）SpringBoot 双数据源</a></h1><div class="content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近项目中需要用到 Springboot + Mybatis 双数据源，一边接入 Oracle，一边接入 MySQL ，折腾了一下。搞了个 demo 出来。</p></div><a class="article-more button is-small is-size-7" href="/post/a0972c39.html#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-11-25T13:55:19.000Z" title="2019-11-25 21:55:19">2019-11-25</time>发表</span><span class="level-item"><time dateTime="2020-03-06T15:19:54.887Z" title="2020-3-6 23:19:54">2020-03-06</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a><span> / </span><a class="link-muted" href="/categories/Java/Effective-Java/">Effective Java</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/post/7d5810ff.html">Effective Java（八）General Programming</a></h1><div class="content"><h1 id="Item-57-最小化局部变量的作用域"><a href="#Item-57-最小化局部变量的作用域" class="headerlink" title="Item 57 最小化局部变量的作用域"></a>Item 57 最小化局部变量的作用域</h1><blockquote>
<p>好的编程习惯：在首次使用的地方声明它。</p>
</blockquote>
<ol>
<li>如果循环终止后不需要循环变量的内容，那么优先选择 for 循环而不是 while 循环。</li>
<li>如果变量需要在 <code>try-catch</code> 之外使用，那就必须在外面提前声明，这是一个例外。其他情况都应该遵循在首次使用的地方声明。</li>
<li>每个行为对应一个方法。保持方法小而集中。</li>
</ol></div><a class="article-more button is-small is-size-7" href="/post/7d5810ff.html#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-11-22T13:39:53.000Z" title="2019-11-22 21:39:53">2019-11-22</time>发表</span><span class="level-item"><time dateTime="2020-03-06T15:20:15.993Z" title="2020-3-6 23:20:15">2020-03-06</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a><span> / </span><a class="link-muted" href="/categories/Java/Effective-Java/">Effective Java</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/post/387fb533.html">Effective Java（七）方法</a></h1><div class="content"><h1 id="Item-49-检查参数有效性"><a href="#Item-49-检查参数有效性" class="headerlink" title="Item 49 检查参数有效性"></a>Item 49 检查参数有效性</h1><p>在 Java 7 之后，可以用 <code>requireNonNull</code> 来判空，如果为空，自动抛出空指针异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.strategy = Objects.requireNonNull(strategy, <span class="string">&quot;strategy&quot;</span>);</span><br></pre></td></tr></table></figure></div><a class="article-more button is-small is-size-7" href="/post/387fb533.html#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-11-19T14:39:14.000Z" title="2019-11-19 22:39:14">2019-11-19</time>发表</span><span class="level-item"><time dateTime="2020-03-06T15:20:11.667Z" title="2020-3-6 23:20:11">2020-03-06</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a><span> / </span><a class="link-muted" href="/categories/Java/Effective-Java/">Effective Java</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/post/cc85a16e.html">Effective Java（六）Lambdas and Streams</a></h1><div class="content"><h1 id="Item-42-lambda-表达式优于匿名类"><a href="#Item-42-lambda-表达式优于匿名类" class="headerlink" title="Item 42 lambda 表达式优于匿名类"></a>Item 42 lambda 表达式优于匿名类</h1><p>Java 的 Lambda 表达式本质上就是一个匿名类。而什么是匿名类？就是在使用的时候现场 new 并实现的类。</p>
<p>只有一个方法的接口称为 <strong>函数式接口（functioning interface）</strong>，Lambda 表达式本质上就是对这样子的接口做现场实现。可以参考我之前写的：<a href="../post/68278ec8.html">Java简明笔记（八）Lambda和函数式编程</a></p>
<p>然而 lambda 也不是万能的，它只对函数是接口有用，如果一个接口有多个方法需要重写，那只能用匿名类。this 关键字在 lambda 中引用封闭实例，在匿名类中引用匿名类实例。如果你需要从其内部访问函数对象，则必须使用匿名类。</p>
<p>Lambdas 与匿名类都无法可靠地序列化和反序列化。因此，尽量少去 (如果有的话) 序列化一个 lambda (或一个匿名类实例)。如果有一个想要进行序列化的函数对象，比如一个 Comparator，那么使用一个私有静态嵌套类的实例（见 Item 24 ）。</p>
<p>作者建议：一行代码对于 lambda 说是理想的，三行代码是合理的最大值。 如果违反这一规定，可能会严重损害程序的可读性。</p></div><a class="article-more button is-small is-size-7" href="/post/cc85a16e.html#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-10-22T14:24:26.000Z" title="2019-10-22 22:24:26">2019-10-22</time>发表</span><span class="level-item"><time dateTime="2020-03-06T15:20:27.825Z" title="2020-3-6 23:20:27">2020-03-06</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a><span> / </span><a class="link-muted" href="/categories/Java/Effective-Java/">Effective Java</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/post/acf36022.html">Effective Java（五）枚举和注解</a></h1><div class="content"><h1 id="Item-34-使用枚举类型替代整型常量"><a href="#Item-34-使用枚举类型替代整型常量" class="headerlink" title="Item 34 使用枚举类型替代整型常量"></a>Item 34 使用枚举类型替代整型常量</h1><p>如果你需要一组常量，比如球的红绿蓝三种颜色，四则运算的加减乘除操作，用枚举类会比用 <code>final static int</code> 或 <code>String</code> 好。枚举更具可读性，更安全，更强大。</p></div><a class="article-more button is-small is-size-7" href="/post/acf36022.html#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-10-18T13:38:49.000Z" title="2019-10-18 21:38:49">2019-10-18</time>发表</span><span class="level-item"><time dateTime="2020-03-06T15:20:23.674Z" title="2020-3-6 23:20:23">2020-03-06</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a><span> / </span><a class="link-muted" href="/categories/Java/Effective-Java/">Effective Java</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/post/53a4cf82.html">Effective Java（四）泛型</a></h1><div class="content"><p>Java 5 加入了泛型。在有泛型之前，你必须转换从集合中读取的每个对象。如果有人不小心插入了错误类型的对象，则在运行时可能会失败。使用泛型，你告诉编译器在集合中允许存放哪些类型的对象。编译器会自动插入强制转换，并在编译时告诉你是否尝试插入错误类型的对象。</p></div><a class="article-more button is-small is-size-7" href="/post/53a4cf82.html#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-10-13T08:58:42.000Z" title="2019-10-13 16:58:42">2019-10-13</time>发表</span><span class="level-item"><time dateTime="2020-03-06T15:20:19.943Z" title="2020-3-6 23:20:19">2020-03-06</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a><span> / </span><a class="link-muted" href="/categories/Java/Effective-Java/">Effective Java</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/post/20ef17da.html">Effective Java（三）类和接口</a></h1><div class="content"><h1 id="Item-15-最小化类和成员的可访问性"><a href="#Item-15-最小化类和成员的可访问性" class="headerlink" title="Item 15 最小化类和成员的可访问性"></a>Item 15 最小化类和成员的可访问性</h1><p>一个设计良好的组件，应该隐藏其内部细节，将 API 与它的实现分离开来，外界只与 API 通信。这也是软件设计的基本原则。</p>
<p>Java中的四种访问级别：</p>
<ul>
<li><strong>private</strong> —— 该成员只能在声明它的顶级类内访问。</li>
<li><strong>package-private</strong> —— 成员可以从被声明的包中的任何类中访问。从技术上讲，如果没有指定访问修饰符（接口除外，它默认是公共的），这是默认访问级别。</li>
<li><strong>protected</strong> —— 成员可以从被声明的类的子类中访问，以及它声明的包中的任何类。</li>
<li><strong>public</strong> —— 该成员可以从任何地方被访问。</li>
</ul>
<p>能用 private 的，绝不用 protected，能用 protected 的，绝不用 public。</p></div><a class="article-more button is-small is-size-7" href="/post/20ef17da.html#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-10-10T14:59:15.000Z" title="2019-10-10 22:59:15">2019-10-10</time>发表</span><span class="level-item"><time dateTime="2020-03-06T15:19:59.439Z" title="2020-3-6 23:19:59">2020-03-06</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a><span> / </span><a class="link-muted" href="/categories/Java/Effective-Java/">Effective Java</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/post/f754c291.html">Effective Java（二）对象通用的方法</a></h1><div class="content"><p>对象通用的方法，指的是 Object 类下的方法，即 toString、equals、hashCode 等等，合理地使用跟重写它们，可以避免很多坑。</p>
<h1 id="Item-10-重写-equals-时请遵守约定"><a href="#Item-10-重写-equals-时请遵守约定" class="headerlink" title="Item 10 重写 equals 时请遵守约定"></a>Item 10 重写 equals 时请遵守约定</h1><p>重写 equals 很容易犯错，最好不要去重写，比如下面的情形：</p>
<ol>
<li>类的每个实例都是唯一的。显而易见，像 Thread 这样表示活动而不是值的类来说，每个实例都是不一样的。</li>
<li>类不需要「逻辑相等（logical equality）」</li>
<li>父类已经重写了 equals 方法，除非有必要，否则子类就不用再去重写了。例如，大多数 List 从 AbstractList 继承了 equals 实现，Map 从 AbstractMap 的 Map 继承了 equals 实现。</li>
</ol></div><a class="article-more button is-small is-size-7" href="/post/f754c291.html#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-09-09T15:35:58.000Z" title="2019-9-9 23:35:58">2019-09-09</time>发表</span><span class="level-item"><time dateTime="2020-03-06T15:19:48.363Z" title="2020-3-6 23:19:48">2020-03-06</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a><span> / </span><a class="link-muted" href="/categories/Java/Effective-Java/">Effective Java</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/post/39fc1edf.html">Effective Java（一）创建和销毁对象</a></h1><div class="content"><p>《Effective Java》这本书算得上有口皆碑了，去年发现出了第三版，趁某东活动入手了一本英文版，粗略了过了一下，这本书给我最大的体会就是它教你如何成为一个真正的 Java 程序员，而不是 CRUD 程序员或 Spring 程序员，读这本书，能让你站在更高的角度和更深层次的视角去剖析 Java 的细节，让人豁然开朗。然而，上半年因为各种原因，瞎忙活了大半年，这本书一直没机会捡起来仔细看。好在最近工作不忙，想起来有这本书，决定一天看两个 Item 。</p>
<p>系列目录：</p>
<ul>
<li><a href="../post/39fc1edf.html">Effective Java（一）创建和销毁对象</a></li>
<li><a href="../post/f754c291.html">Effective Java（二）对象通用的方法</a></li>
<li><a href="../post/20ef17da.html">Effective Java（三）类和接口</a></li>
<li><a href="../post/53a4cf82.html">Effective Java（四）泛型</a></li>
<li><a href="../post/acf36022.html">Effective Java（五）枚举和注解</a></li>
<li><a href="../post/cc85a16e.html">Effective Java（六）Lambdas and Streams</a></li>
<li><a href="../post/387fb533.html">Effective Java（七）方法</a></li>
<li><a href="../post/7d5810ff.html">Effective Java（八）General Programming</a></li>
<li><a href="../post/4e34dae4.html">Effective Java（九）异常</a></li>
<li>Effective Java（十）并发</li>
</ul></div><a class="article-more button is-small is-size-7" href="/post/39fc1edf.html#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-06-04T16:25:54.000Z" title="2019-6-5 0:25:54">2019-06-05</time>发表</span><span class="level-item"><time dateTime="2021-04-05T12:09:58.520Z" title="2021-4-5 20:09:58">2021-04-05</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a><span> / </span><a class="link-muted" href="/categories/Java/Concurrent/">Concurrent</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/post/377edbcb.html">Java并发编程之异步任务</a></h1><div class="content"><p>有时候，我们想在主线程之外执行一些异步任务，不难想到，可以开一个新线程专门去处理某个任务。</p></div><a class="article-more button is-small is-size-7" href="/post/377edbcb.html#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-06-04T03:21:31.000Z" title="2019-6-4 11:21:31">2019-06-04</time>发表</span><span class="level-item"><time dateTime="2020-03-06T15:24:14.699Z" title="2020-3-6 23:24:14">2020-03-06</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a><span> / </span><a class="link-muted" href="/categories/Java/Java-SE/">Java SE</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/post/b3112bec.html">Java简明笔记（十七）注解</a></h1><div class="content"><h1 id="注解魔法"><a href="#注解魔法" class="headerlink" title="注解魔法"></a>注解魔法</h1><p>注解是一种标记。在 Java 中，随处可见<code>@Override</code>、<code>@Deprecated</code>这样的注解。说实话，Java的注解经常不被重视，以至于学习的时候习惯性略过。在学了Spring框架后发现Spring使用了大量的注解来简化开发和配置，回过头来才发现注解的魅力。</p></div><a class="article-more button is-small is-size-7" href="/post/b3112bec.html#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-01-10T10:01:15.000Z" title="2019-1-10 18:01:15">2019-01-10</time>发表</span><span class="level-item"><time dateTime="2020-03-06T15:24:17.900Z" title="2020-3-6 23:24:17">2020-03-06</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a><span> / </span><a class="link-muted" href="/categories/Java/Java-SE/">Java SE</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/post/bbbc0df0.html">Java简明笔记（十六）网络编程</a></h1><div class="content"><p><img src="../../../../images/Java/socket_title.jpg" alt="socket_title"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>网络编程，顾名思义就是编写通过网络通信的计算机程序。提到网络编程，一般指 socket 编程，之前我写过两篇相关的文章，分别是：<a href="../post/bfa70c14.html">浅谈 socket 编程</a> 和 <a href="../post/78265215.html">Socket编程实践（Java &amp; Python实现）</a>，主要侧重于 socket 编程的理解，而这一篇侧重于使用 Java 进行 socket 编程的要点，作为简明笔记，以备后续用到时方便查阅。</p></div><a class="article-more button is-small is-size-7" href="/post/bbbc0df0.html#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2018-11-11T05:10:53.000Z" title="2018-11-11 13:10:53">2018-11-11</time>发表</span><span class="level-item"><time dateTime="2020-03-06T15:27:28.376Z" title="2020-3-6 23:27:28">2020-03-06</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java-Web/">Java Web</a><span> / </span><a class="link-muted" href="/categories/Java-Web/Spring/">Spring</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/post/cf93e9b3.html">Spring（八）SpringBoot 集成 JPA</a></h1><div class="content"><h1 id="什么是-JPA-？"><a href="#什么是-JPA-？" class="headerlink" title="什么是 JPA ？"></a>什么是 JPA ？</h1><p>之前在 Spring Boot 工程中，一直用 Mybatis 注解方式作为持久层框架。但是 Mybatis 需要手写 SQL 语句，对于简单的项目稍显麻烦。最近发现了 JPA ，使用 JPA 我们几乎可以不用写一句 SQL 语句，非常适合 CURD 场景。JPA 是 Java Persistence API（Java持久化接口） 的缩写。JPA 让我们的应用程序以统一的方式访问持久层。JPA 是 Hibernate 的一个抽象，是一种 ORM 规范，是可以理解为是 Hibernate 功能的一个子集。</p></div><a class="article-more button is-small is-size-7" href="/post/cf93e9b3.html#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2018-10-30T07:08:26.000Z" title="2018-10-30 15:08:26">2018-10-30</time>发表</span><span class="level-item"><time dateTime="2021-04-21T14:51:17.954Z" title="2021-4-21 22:51:17">2021-04-21</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a><span> / </span><a class="link-muted" href="/categories/Java/Concurrent/">Concurrent</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/post/a23f9c20.html">Java并发编程之并发工具</a></h1><div class="content"><p>Java自带的平台类库（java.util.concurrent）里面包含了很多有用的工具，来帮助我们更好地处理并发问题。这一篇主要介绍一下几类工具：</p>
<ol>
<li><strong>atomic原子类</strong>：AtomicLong</li>
<li><strong>同步容器类</strong>：Vector、Hashtable</li>
<li><strong>并发容器类</strong>：concurrentHashMap、ConcurrentLinkedQueue、BlockingQueue（阻塞队列）</li>
<li><strong>并发工具类</strong>：闭锁（Latch）、栅栏（Barrier）、信号量（Semaphore）</li>
</ol></div><a class="article-more button is-small is-size-7" href="/post/a23f9c20.html#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2018-10-28T08:22:48.000Z" title="2018-10-28 16:22:48">2018-10-28</time>发表</span><span class="level-item"><time dateTime="2020-08-30T10:21:58.493Z" title="2020-8-30 18:21:58">2020-08-30</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a><span> / </span><a class="link-muted" href="/categories/Java/JVM/">JVM</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/post/a3255dff.html">Java虚拟机（五）JVM参数和调优</a></h1><div class="content"><h1 id="本地线程分配缓冲（TLAB）"><a href="#本地线程分配缓冲（TLAB）" class="headerlink" title="本地线程分配缓冲（TLAB）"></a>本地线程分配缓冲（TLAB）</h1><p>Java虚拟机遇到 new 指令时，需要在堆内存上为新对象分配内存空间。如果堆是规整的，一边是分配过的内存，一边是空闲内存，那只要在中间用一个指针隔开，为新对象分配内存时，指针往后移动相应的空间距离即可。</p>
<p><img src="../../../../images/Java/pointer_move.png" alt="pointer_move"></p></div><a class="article-more button is-small is-size-7" href="/post/a3255dff.html#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2018-10-11T14:33:15.000Z" title="2018-10-11 22:33:15">2018-10-11</time>发表</span><span class="level-item"><time dateTime="2020-03-06T15:27:12.102Z" title="2020-3-6 23:27:12">2020-03-06</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java-Web/">Java Web</a><span> / </span><a class="link-muted" href="/categories/Java-Web/Spring/">Spring</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/post/3fc0f79e.html">Spring（七）深入理解Spring MVC</a></h1><div class="content"><p><img src="../../../../images/Webapp/How_MVC_Works.webp"></p>
<p>我们通过 Spring Boot 来创建一个 Web 应用，发挥作用的是 Spring MVC 框架。当我们在IDE里敲入以下代码时，究竟发生了什么呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">login</span><span class="params">(LoginData loginData)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (LOGIN.equals(loginData.getLogin())</span><br><span class="line">      &amp;&amp; PASSWORD.equals(loginData.getPassword())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">&quot;success&quot;</span>,</span><br><span class="line">          Collections.singletonMap(<span class="string">&quot;login&quot;</span>, loginData.getLogin()));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">&quot;failure&quot;</span>,</span><br><span class="line">          Collections.singletonMap(<span class="string">&quot;login&quot;</span>, loginData.getLogin()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><a class="article-more button is-small is-size-7" href="/post/3fc0f79e.html#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2018-09-07T12:47:06.000Z" title="2018-9-7 20:47:06">2018-09-07</time>发表</span><span class="level-item"><time dateTime="2020-03-30T15:02:46.082Z" title="2020-3-30 23:02:46">2020-03-30</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a><span> / </span><a class="link-muted" href="/categories/Java/Java-SE/">Java SE</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/post/44627f59.html">Java简明笔记（十五）Java NIO</a></h1><div class="content"><h1 id="什么是-Java-NIO"><a href="#什么是-Java-NIO" class="headerlink" title="什么是 Java NIO"></a>什么是 Java NIO</h1><p>Java NIO， N 可以理解为 New ，也可以理解为 Non-blocking ，是 Java 1.4 之后新的一套区别于标准 Java IO 和 Java Networking 的 API 。NIO 跟传统的 BIO 之间最大的区别在于 NIO 是面向 Channels 和 Buffers 的，一个线程可以通过 Selector 管理多个 Channels ，继而管理多个连接，在线程进行 IO 操作时不会阻塞。</p></div><a class="article-more button is-small is-size-7" href="/post/44627f59.html#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2018-08-10T13:32:32.000Z" title="2018-8-10 21:32:32">2018-08-10</time>发表</span><span class="level-item"><time dateTime="2020-08-30T10:22:00.819Z" title="2020-8-30 18:22:00">2020-08-30</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a><span> / </span><a class="link-muted" href="/categories/Java/JVM/">JVM</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/post/2191536a.html">Java虚拟机（四）垃圾回收策略</a></h1><div class="content"><p><img src="../../../../images/Java/GC.png" alt="GC.png"></p>
<p>在 <a href="../post/7a1af8ce.html">Java虚拟机（二）内存模型和对象创建</a> 这一篇中，我们知道 Java 虚拟机的内存模型包含五个部分：程序计数器、Java虚拟机栈、本地方法栈、堆、方法区。这五个区域也叫运行时数据区域（Runtime Data Area），他们是数据的存储空间。既然是存储空间，那就有可能达到存满的时候，因此，JVM必须配备一个垃圾回收器（Garbage Collection, GC），用于不定期地回收不再需要的内存空间。</p></div><a class="article-more button is-small is-size-7" href="/post/2191536a.html#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2018-08-09T13:30:49.000Z" title="2018-8-9 21:30:49">2018-08-09</time>发表</span><span class="level-item"><time dateTime="2020-08-30T10:21:23.109Z" title="2020-8-30 18:21:23">2020-08-30</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a><span> / </span><a class="link-muted" href="/categories/Java/JVM/">JVM</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/post/d15ce8f0.html">Java虚拟机（三）Class文件结构</a></h1><div class="content"><h1 id="class-文件简介"><a href="#class-文件简介" class="headerlink" title="class 文件简介"></a>class 文件简介</h1><p>class 文件是javac编译器编译后生成的二进制文件,全部是连续的0/1。可以把 class 文件中的内容分为两种类型：</p>
<ol>
<li><strong>无符号数</strong>：表示class文件中的值，没有符号，但有长度。u1、u2、u4、u8 （u1表示1字节的无符号数）</li>
<li><strong>表</strong>：无符号数要么单独存在，要么多个组合成为二维表。</li>
</ol>
<p>总而言之，class文件中的数据要么是单个值，要么是二维表。</p></div><a class="article-more button is-small is-size-7" href="/post/d15ce8f0.html#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2018-08-04T11:51:52.000Z" title="2018-8-4 19:51:52">2018-08-04</time>发表</span><span class="level-item"><time dateTime="2020-06-29T14:47:50.120Z" title="2020-6-29 22:47:50">2020-06-29</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a><span> / </span><a class="link-muted" href="/categories/Java/JVM/">JVM</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/post/7a1af8ce.html">Java虚拟机（二）内存模型和对象创建</a></h1><div class="content"><h1 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h1><p>Java 程序执行的过程中，虚拟机所管理的内存划分为如下几个不同的数据区域：</p>
<p><img src="../../../../images/Java/JVM_Memory.png"></p></div><a class="article-more button is-small is-size-7" href="/post/7a1af8ce.html#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2018-08-04T04:53:58.000Z" title="2018-8-4 12:53:58">2018-08-04</time>发表</span><span class="level-item"><time dateTime="2020-09-03T15:45:55.620Z" title="2020-9-3 23:45:55">2020-09-03</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a><span> / </span><a class="link-muted" href="/categories/Java/JVM/">JVM</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/post/3ebede8.html">Java虚拟机（一）JVM 基础和类的加载</a></h1><div class="content"><h1 id="什么是Java虚拟机"><a href="#什么是Java虚拟机" class="headerlink" title="什么是Java虚拟机"></a>什么是Java虚拟机</h1><p>Java的理念是“一次编译，到处运行”。我们平时编写的 Java 代码，经过Java编译器编译后会生成一种 .class 文件，称为字节码文件。<font color="red">Java虚拟机（Java Virtual Machine，JVM）就是负责将字节码文件翻译成特定平台下的机器码然后运行的软件，其本身是由C/C++编写</font>。</p></div><a class="article-more button is-small is-size-7" href="/post/3ebede8.html#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2018-07-09T14:33:32.000Z" title="2018-7-9 22:33:32">2018-07-09</time>发表</span><span class="level-item"><time dateTime="2020-03-06T15:27:32.876Z" title="2020-3-6 23:27:32">2020-03-06</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java-Web/">Java Web</a><span> / </span><a class="link-muted" href="/categories/Java-Web/Spring/">Spring</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/post/fd78ec01.html">Spirng（六） IoC容器探究</a></h1><div class="content"><p><img src="../../../../images/Java/Spring.png" alt="Spring"></p>
<p>在 <a href="../post/6200df85.html">Spring（一）从 传统Java Web到SpirngBoot</a> 中对 Ioc 的概念已经有了初步认识：Spring 通过一个配置文件描述 Bean 与 Bean 之间的依赖关系，利用 Java 的类加载器和反射机制实例化 Bean 并建立 Bean 之间的依赖关系。</p>
<p>我们将调用类对某一接口实现类的依赖关系交由 Spring 容器管理，容器在我们需要的时候，通过注入及时地将对象进行实例化并装配好 bean，无需我们自己 new 。</p>
<p>除此之外，由于JDK提供的访问资源的类对底层资源并不友好，缺少从类路径或者Web容器的上下文获取资源的操作类，<strong>Spring重新设计了一个 Resource 接口</strong>，用于更强的底层资源访问能力。有了这个资源类，就可以将Spring的配置信息放在任何地方（数据库、LDAP）。而为了访问不同类型的资源，<strong>Spring还提供了一个强大的加载资源的机制</strong>，定义了一套资源加载的接口 ResourceLoader 及其实现类，可以访问包括<code>classpath:</code>、<code>file:</code>、<code>http://</code>、<code>ftp://</code>等地址前缀资源。</p>
<p>这一篇具体讲讲关于 Spring Ioc的更多内容。</p></div><a class="article-more button is-small is-size-7" href="/post/fd78ec01.html#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2018-06-09T01:39:26.000Z" title="2018-6-9 9:39:26">2018-06-09</time>发表</span><span class="level-item"><time dateTime="2020-03-06T15:26:09.697Z" title="2020-3-6 23:26:09">2020-03-06</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a><span> / </span><a class="link-muted" href="/categories/Java/Java-SE/">Java SE</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/post/98aa81f1.html">Java中的回调机制</a></h1><div class="content"><p>什么是回调（CallBack）呢？有一个经典的打电话例子。</p>
<blockquote>
<p>有一天小王遇到一个很难的问题，问题是“1 + 1 = ?”，就打电话问小李，小李一下子也不知道，就跟小王说，等我办完手上的事情，就去想想答案，小王也不会傻傻的拿着电话去等小李的答案吧，于是小王就对小李说，我还要去逛街，你知道了答案就打我电话告诉我，于是挂了电话，自己办自己的事情，过了一个小时，小李打了小王的电话，告诉他答案是2</p>
</blockquote>
<p>所谓回调：就是A类中调用B类中的某个方法C，然后B类中反过来调用A类中的方法D，D这个方法就叫回调方法。</p>
<p>回调让模块与模块之间解耦，也实现了异步调用。</p></div><a class="article-more button is-small is-size-7" href="/post/98aa81f1.html#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2018-04-18T09:09:56.000Z" title="2018-4-18 17:09:56">2018-04-18</time>发表</span><span class="level-item"><time dateTime="2020-03-06T15:27:08.806Z" title="2020-3-6 23:27:08">2020-03-06</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java-Web/">Java Web</a><span> / </span><a class="link-muted" href="/categories/Java-Web/Spring/">Spring</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/post/1459f5bc.html">Spring（三）Spring MVC</a></h1><div class="content"><p>在 <a href="../post/6200df85.html">从MVC到Spring Boot</a> 这一篇中，搭建了 Spring Boot 的 Hello World 程序。这一篇继续学习基于 Spring MVC 框架的应用程序。应用程序由Spring Boot搭建。</p></div><a class="article-more button is-small is-size-7" href="/post/1459f5bc.html#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2018-04-17T15:48:59.000Z" title="2018-4-17 23:48:59">2018-04-17</time>发表</span><span class="level-item"><time dateTime="2020-03-06T15:27:19.882Z" title="2020-3-6 23:27:19">2020-03-06</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java-Web/">Java Web</a><span> / </span><a class="link-muted" href="/categories/Java-Web/Spring/">Spring</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/post/72ef7508.html">Spring（二） SpringBoot 集成 Mybatis</a></h1><div class="content"><p><img src="http://www.mybatis.org/images/mybatis-logo.png" alt="mybatis"></p>
<p>在 <a href="../post/f251f1b.html">使用 Mybatis 简化 JDBC 操作</a> 中，简单描述了 Mybatis 的使用。这一篇主要记录下如何集成 Spring boot</p>
<hr>
<h1 id="Spring-Boot-集成-Mybatis-简明过程"><a href="#Spring-Boot-集成-Mybatis-简明过程" class="headerlink" title="Spring Boot 集成 Mybatis 简明过程"></a>Spring Boot 集成 Mybatis 简明过程</h1><p>创建一个 Spring Initalizr 工程，依赖选择 web、MySQL、Mybatis</p>
<p>在application.properties填入以下内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.url&#x3D;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;neu?characterEncoding&#x3D;UTF-8&amp;useSSL&#x3D;false</span><br><span class="line">spring.datasource.username&#x3D;root</span><br><span class="line">spring.datasource.password&#x3D;YourPassword</span><br><span class="line">spring.datasource.driver-class-name&#x3D;com.mysql.jdbc.Driver</span><br></pre></td></tr></table></figure>

<ul>
<li>创建pojo包，创建 Student 实体类，跟数据库对应</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    Integer id;</span><br><span class="line">    String name;</span><br><span class="line">    String major;</span><br><span class="line">    Integer grade;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略 getter setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>创建mapper包，创建StudentMapper接口</li>
</ul>
<blockquote>
<p>在SpringBootApplication类中，添加<code>@MapperScan(&quot;io.jerrysheh.student.mapper&quot;)</code>注解，即可不用在 mapper 包下面的每一个接口都注解Mapper了。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;SELECT * FROM student&quot;)</span></span><br><span class="line">    <span class="function">List&lt;Student&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果有多个参数，用 <code>@Param</code> 注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Update(&quot;update user set password=#&#123;password&#125; WHERE id=#&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updatePassword</span><span class="params">(<span class="meta">@Param(&quot;password&quot;)</span> String password, <span class="meta">@Param(&quot;id&quot;)</span> Integer id)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>创建Controller包，创建StudentController</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    StudentMapper studentMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/listStudent&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listStudent</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Student&gt; studentList = studentMapper.findAll();</span><br><span class="line">        <span class="keyword">for</span> (Student student:</span><br><span class="line">             studentList) &#123;</span><br><span class="line">            System.out.println(student.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，运行后访问 <code>127.0.0.1:8080/listStudent</code> ，可看到控制台输出数据库查到的所有 student 名字。</p>
<h2 id="xml-方式"><a href="#xml-方式" class="headerlink" title="xml 方式"></a>xml 方式</h2><p>有时候为了将SQL和Java代码隔离 ，会将 SQL 抽到 xml 里面，配置方法如下：</p>
<p>在application.properties填入以下内容(重要！！！)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mybatis.mapper-locations&#x3D;classpath:mapper&#x2F;*.xml</span><br><span class="line">mybatis.type-aliases-package&#x3D;com.jerrysheh.fun.entity</span><br><span class="line">mybatis.configuration.map-underscore-to-camel-case&#x3D;true</span><br></pre></td></tr></table></figure>

<p>在 resources 目录下创建 mapper 文件夹，再创建 productmapper.xml 文件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.jerrysheh.fun.mapper.ProductMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.jerrysheh.fun.entity.Product&quot;</span>&gt;</span></span><br><span class="line">        SELECT * FROM fun_product;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addProduct&quot;</span> &gt;</span></span><br><span class="line">        insert into fun_product(product_name, product_price) values (#&#123;productName&#125;, #&#123;productPrice&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：namespace一定要填写对应的 mapper 接口，不能只到 package</p>
</blockquote>
<p>编写单元测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ProductMapper productMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Product&gt; productList = productMapper.selectAll();</span><br><span class="line">        productList.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>以下为Mybatis知识点</p>
<h1 id="井字符和美元符的区别"><a href="#井字符和美元符的区别" class="headerlink" title="井字符和美元符的区别"></a>井字符和美元符的区别</h1><p>#相当于对数据加上双引号，$相当于直接显示数据</p>
<p>#方式能够很大程度防止sql注入。$方式无法防止Sql注入。</p>
<hr>
<h1 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h1><p>虽然我们使用了注解，但是还是在注解接口CategoryMapper中使用了原生 SQL 语句。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Insert(&quot; insert into category_ ( name ) values (#&#123;name&#125;) &quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(Category category)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其实，我们可以提供一个类，专门用来生成SQL语句</p>
<p>CategoryDynaSqlProvider.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jerrysheh.mapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.jdbc.SQL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CategoryDynaSqlProvider</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SQL()</span><br><span class="line">                .SELECT(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">                .FROM(<span class="string">&quot;category_&quot;</span>)</span><br><span class="line">                .toString();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SQL()</span><br><span class="line">                .SELECT(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">                .FROM(<span class="string">&quot;category_&quot;</span>)</span><br><span class="line">                .WHERE(<span class="string">&quot;id=#&#123;id&#125;&quot;</span>)</span><br><span class="line">                .toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SQL()</span><br><span class="line">                .INSERT_INTO(<span class="string">&quot;category_&quot;</span>)</span><br><span class="line">                .VALUES(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;#&#123;name&#125;&quot;</span>)</span><br><span class="line">                .toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">update</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SQL()</span><br><span class="line">                .UPDATE(<span class="string">&quot;category_&quot;</span>)</span><br><span class="line">                .SET(<span class="string">&quot;name=#&#123;name&#125;&quot;</span>)</span><br><span class="line">                .WHERE(<span class="string">&quot;id=#&#123;id&#125;&quot;</span>)</span><br><span class="line">                .toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">delete</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SQL()</span><br><span class="line">                .DELETE_FROM(<span class="string">&quot;category_&quot;</span>)</span><br><span class="line">                .WHERE(<span class="string">&quot;id=#&#123;id&#125;&quot;</span>)</span><br><span class="line">                .toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后修改我们的CategoryMapper接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jerrysheh.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.jerrysheh.pojo.Category;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CategoryMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@InsertProvider(type=CategoryDynaSqlProvider.class,method=&quot;add&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(Category category)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteProvider(type=CategoryDynaSqlProvider.class,method=&quot;delete&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SelectProvider(type=CategoryDynaSqlProvider.class,method=&quot;get&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Category <span class="title">get</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@UpdateProvider(type=CategoryDynaSqlProvider.class,method=&quot;update&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Category category)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SelectProvider(type=CategoryDynaSqlProvider.class,method=&quot;list&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Category&gt; <span class="title">list</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以动态生成SQL语句了</p>
<ul>
<li>注解中的 <code>type=</code> 填入我们的动态生成SQL类CategoryDynaSqlProvider.class</li>
<li><code>method=</code>填入CategoryDynaSqlProvider类里的方法</li>
</ul>
<hr>
<h1 id="Results结果映射"><a href="#Results结果映射" class="headerlink" title="@Results结果映射"></a>@Results结果映射</h1><p>如果 javabean 的属性字段 跟 数据库字段一一对应，名字保持一致，则直接可以：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select *from Demo where id=#&#123;id&#125;&quot;)</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> Demo <span class="title">selectById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;  </span><br></pre></td></tr></table></figure>

<p>但如果不对应，就要用<code>@Result</code>修饰返回的结果集，而<code>@Results</code>注解将指定的数据库列与指定JavaBean属性映射起来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;SELECT * FROM `wx_message_config` WHERE `content_key_words` IS NOT NULL AND LENGTH(content_key_words) &gt; 0&quot;)</span></span><br><span class="line"><span class="meta">@Results(&#123;</span></span><br><span class="line"><span class="meta">        @Result(property = &quot;msgType&quot;, column = &quot;msg_type&quot;),</span></span><br><span class="line"><span class="meta">        @Result(property = &quot;eventType&quot;, column = &quot;event_type&quot;),</span></span><br><span class="line"><span class="meta">        @Result(property = &quot;eventKey&quot;,column = &quot;event_key&quot;),</span></span><br><span class="line"><span class="meta">        @Result(property = &quot;contentKeyWords&quot;,column = &quot;content_key_words&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="function">List&lt;WxMessageConfig&gt; <span class="title">queryAllKeyWords</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Select(&quot;SELECT * FROM `wx_message_config` WHERE `id` = #&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="meta">@Results(&#123;</span></span><br><span class="line"><span class="meta">        @Result(property = &quot;msgType&quot;, column = &quot;msg_type&quot;),</span></span><br><span class="line"><span class="meta">        @Result(property = &quot;eventType&quot;, column = &quot;event_type&quot;),</span></span><br><span class="line"><span class="meta">        @Result(property = &quot;eventKey&quot;,column = &quot;event_key&quot;),</span></span><br><span class="line"><span class="meta">        @Result(property = &quot;contentKeyWords&quot;,column = &quot;content_key_words&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="function">WxMessageConfig <span class="title">queryKwById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这样会导致写很多重复内容，可以用 <code>@ResultMap(“id”) </code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;SELECT id, name, password FROM user WHERE id = #&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="meta">@Results(id = &quot;userMap&quot;, value = &#123; @Result(column = &quot;id&quot;, property = &quot;id&quot;, javaType = Integer.class),</span></span><br><span class="line"><span class="meta">        @Result(column = &quot;name&quot;, property = &quot;name&quot;, javaType = String.class),</span></span><br><span class="line"><span class="meta">        @Result(column = &quot;password&quot;, property = &quot;password&quot;, javaType = String.class) &#125;)</span></span><br><span class="line"><span class="function">User <span class="title">findById</span><span class="params">(Integer id)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Select(&quot;SELECT * FROM user&quot;)</span></span><br><span class="line"><span class="meta">@ResultMap(&quot;userMap&quot;)</span></span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">fingAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="一对多查询"><a href="#一对多查询" class="headerlink" title="一对多查询"></a>一对多查询</h1><p>假设有一张 商品表 和 一张 图片表， 一个商品对应多张图片</p>
<p><img src="../../../../images/Webapp/mybatis2.png"></p>
<p><img src="../../../../images/Webapp/mybatis3.png"></p>
<p>那么如何取出一个商品，包含商品的所有属性，以及对应的所有图片呢？</p>
<h2 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h2><p>商品的所有字段，同时，要添加一个 <code>List&lt;String&gt;</code> 表示多张图片的集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> Integer user_id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String price;</span><br><span class="line">    <span class="keyword">private</span> Date gmt_create;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">    <span class="keyword">private</span> Integer cate_id;</span><br><span class="line">    <span class="keyword">private</span> Integer number;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关键！</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; link;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略 getter setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>图片的所有属性，用 String 表示图片地址</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Image</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> Integer product_id;</span><br><span class="line">    <span class="keyword">private</span> String link;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Mapper接口"><a href="#Mapper接口" class="headerlink" title="Mapper接口"></a>Mapper接口</h2><p>在图片的Mapper接口中，根据商品id找到对应的所有图片</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据商品id找图片</span></span><br><span class="line"><span class="meta">@Select(&quot;SELECT link from image WHERE product_id = #&#123;product_id&#125;&quot;)</span></span><br><span class="line"><span class="function">List&lt;String&gt; <span class="title">getImageLinksByProductId</span><span class="params">(Integer product_id)</span></span>;</span><br></pre></td></tr></table></figure>

<p>在商品的Mapper接口中，通过 <code>@Results</code> 和 <code>@Many</code> 来进行关联</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取出在售的所有商品，最新的排前面</span></span><br><span class="line"><span class="meta">@Select(&quot;select * from product WHERE number &gt; 0 ORDER BY id DESC&quot;)</span></span><br><span class="line"><span class="meta">@Results(&#123;</span></span><br><span class="line"><span class="meta">        // 这里要对id进行限定，否则 id 会为 null</span></span><br><span class="line"><span class="meta">        @Result(property = &quot;id&quot;, column = &quot;id&quot;),</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">        // 将 image 的 link 和 product 的 id 绑定，通过 @Many 查询 返回 List</span></span><br><span class="line"><span class="meta">        @Result(property = &quot;link&quot;, column = &quot;id&quot;, javaType = List.class, many = @Many(select = &quot;com.zsc.tradeplatform.mapper.ImageMapper.getImageLinksByProductId&quot;)),</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="function">List&lt;Product&gt; <span class="title">getAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/api/product&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Product&gt; <span class="title">getAllProduct</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> productService.getAllProduct();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>访问 <code>127.0.0.1:8080/api/product</code> 查看结果</p>
<p><img src="../../../../images/Webapp/mybatisOneToManyResult.png"></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2018-04-16T13:58:52.000Z" title="2018-4-16 21:58:52">2018-04-16</time>发表</span><span class="level-item"><time dateTime="2020-03-06T15:30:09.391Z" title="2020-3-6 23:30:09">2020-03-06</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a><span> / </span><a class="link-muted" href="/categories/Java/JDBC/">JDBC</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/post/f251f1b.html">使用 Mybatis 简化 JDBC 操作</a></h1><div class="content"><p><img src="http://www.mybatis.org/images/mybatis-logo.png" alt="mybatis"></p>
<p>在 <a href="../post/f07211ef.html">Java简明笔记（十三）JDBC</a> 中，使用 JDBC 来操作数据库，并把查询到的数据库信息进行 java 对象的映射（ORM），但是 JDBC 除了需要自己写SQL之外，还必须操作Connection, Statment, ResultSet，显得繁琐和枯燥。于是我们对 JDBC 进行封装，以简化数据库操作。mybatis就是这样的一个框架。</p>
<p>以下简介摘自<a target="_blank" rel="noopener" href="http://www.mybatis.org/mybatis-3/zh/index.html">官方文档</a>：</p>
<blockquote>
<p>MyBatis是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。</p>
</blockquote></div><a class="article-more button is-small is-size-7" href="/post/f251f1b.html#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2018-04-14T16:19:08.000Z" title="2018-4-15 0:19:08">2018-04-15</time>发表</span><span class="level-item"><time dateTime="2020-05-10T08:12:14.683Z" title="2020-5-10 16:12:14">2020-05-10</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java-Web/">Java Web</a><span> / </span><a class="link-muted" href="/categories/Java-Web/Spring/">Spring</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/post/6200df85.html">Spring（一）从传统Java Web到SpirngBoot</a></h1><div class="content"><h1 id="从-MVC-结构到-Web-框架"><a href="#从-MVC-结构到-Web-框架" class="headerlink" title="从 MVC 结构到 Web 框架"></a>从 MVC 结构到 Web 框架</h1><p>Java Web 技术日新月异，如今，我们开发 Java Web 项目都是靠框架快速搭建。然而，为什么需要框架？还得从传统的 MVC 结构说起。</p>
<h2 id="传统-Model-View-Controller-架构"><a href="#传统-Model-View-Controller-架构" class="headerlink" title="传统 Model-View-Controller 架构"></a>传统 Model-View-Controller 架构</h2><p>典型的Java Web应用架构如下：</p>
<p><img src="../../../../images/Webapp/MVC.jpg" alt="MVC"></p>
<ol>
<li>浏览器发送 HTTP 请求到服务端，被 Controller(Servlet) 获取并进行处理（参数解析、请求转发）</li>
<li>Controller 调用核心业务逻辑 —— Model</li>
<li>Model 进行数据库存取操作，并将操作结果返回</li>
<li>Controller 将业务逻辑处理结果交给View（JSP），动态输出 HTML 内容</li>
<li>动态生成的 HTML 内容返回到浏览器显示</li>
</ol>
<h2 id="封装-Servlet"><a href="#封装-Servlet" class="headerlink" title="封装 Servlet"></a>封装 Servlet</h2><p>在这个过程中，我们要操作 Servlet 写大量的功能代码，为了简化，我们可以把 Servlet 中经常要实现的功能封装起来并提供一层公共抽象，这样我们只要编写简单的 POJO 代码或者实现一些接口，就能完成复杂的 Web 请求的后端逻辑处理。 Spring MVC 就是这样的一个框架。它提供了一个DispacherServlet，我们只需实现 Spring MVC 提供的接口就可以完成复杂的操作，而不用写大量的 Servlet 代码。</p></div><a class="article-more button is-small is-size-7" href="/post/6200df85.html#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2018-04-14T02:35:48.000Z" title="2018-4-14 10:35:48">2018-04-14</time>发表</span><span class="level-item"><time dateTime="2020-03-06T15:26:06.116Z" title="2020-3-6 23:26:06">2020-03-06</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a><span> / </span><a class="link-muted" href="/categories/Java/Java-SE/">Java SE</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/post/ae9388fa.html">Java中的引用类型</a></h1><div class="content"><h1 id="什么是引用类型"><a href="#什么是引用类型" class="headerlink" title="什么是引用类型"></a>什么是引用类型</h1><p><code>引用类型（reference type）</code>是一种基于类的数据类型。Java中，除去基本数据类型外，其它类型都是引用类型。包括Java提供的或者自己定义的class类。</p>
<p>当我们对某个对象声明一个变量的时候，例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ball b1 &#x3D; new Ball();</span><br></pre></td></tr></table></figure>

<p>变量 b1 事实上指向了这个对象的引用，而不是对象本身。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ball b2 &#x3D; b1;</span><br></pre></td></tr></table></figure>

<p>b2 和 b1 都指向了 ball 类的同一个实例。</p>
<p>Java中有四种引用：</p>
<ul>
<li>强引用（Strong Reference）</li>
<li>软引用（Soft Reference）</li>
<li>弱引用（Weak Reference）</li>
<li>虚引用（Phantom Reference）</li>
</ul></div><a class="article-more button is-small is-size-7" href="/post/ae9388fa.html#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2018-04-11T11:41:48.000Z" title="2018-4-11 19:41:48">2018-04-11</time>发表</span><span class="level-item"><time dateTime="2020-08-28T14:00:22.542Z" title="2020-8-28 22:00:22">2020-08-28</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java-Web/">Java Web</a><span> / </span><a class="link-muted" href="/categories/Java-Web/Web/">Web</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/post/d772a9a7.html">Java Web 跳坑手册</a></h1><div class="content"><p>这里有个坑，你要跳吗？</p></div><a class="article-more button is-small is-size-7" href="/post/d772a9a7.html#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2018-03-31T13:20:17.000Z" title="2018-3-31 21:20:17">2018-03-31</time>发表</span><span class="level-item"><time dateTime="2020-07-26T14:19:00.379Z" title="2020-7-26 22:19:00">2020-07-26</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a><span> / </span><a class="link-muted" href="/categories/Java/Java-SE/">Java SE</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/post/e753fbbb.html">Java简明笔记（十四）反射机制</a></h1><div class="content"><p>Java 是完全面向对象语言。事实上，我们创建的每一个类，其实也是对象，称为<code>类对象</code>。类对象提供了类的元信息，比如这个类有几种构造方法，有多少个属性，有哪些普通方法等。</p>
<p><img src="../../../../images/Java/metaobject.png" alt="meta"></p>
<p>Java反射机制主要提供了以下功能：</p>
<ul>
<li>在运行时判断任意一个对象所属的类；</li>
<li>在运行时构造任意一个类的对象；</li>
<li>在运行时判断任意一个类所具有的成员变量和方法；</li>
<li>在运行时调用任意一个对象的方法；生成动态代理。</li>
</ul></div><a class="article-more button is-small is-size-7" href="/post/e753fbbb.html#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2018-03-30T08:08:54.000Z" title="2018-3-30 16:08:54">2018-03-30</time>发表</span><span class="level-item"><time dateTime="2021-04-21T14:43:22.973Z" title="2021-4-21 22:43:22">2021-04-21</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a><span> / </span><a class="link-muted" href="/categories/Java/Concurrent/">Concurrent</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/post/b4ed848b.html">Java并发编程之安全性</a></h1><div class="content"><p>并发编程显然有很多优势，然而，多线程也带来了一定的风险。例如安全性问题、活跃性问题、性能问题等。</p>
<ul>
<li><strong>安全性问题</strong>： 含义是“永远不发生糟糕的事情”，例如多个线程同时修改一个共享变量，导致结果跟预期不符。</li>
<li><strong>活跃性问题</strong>： 关注“某件正确的事情最终会发生”，假若不能，就会产生活跃性问题。例如死锁，A、B进程互相等待对方释放某资源，结果谁也执行不下去。</li>
<li><strong>性能问题</strong>： 在解决安全性问题和活跃性问题的时候会带来额外开销，我们必须想办法减少开销。</li>
</ul>
<p>并发编程的问题，在<a href="../post/727d207c.html">Java简明笔记（十一） 并发编程</a>中就有提及，这一篇，主要就安全性问题，详细谈谈Java并发编程的问题。</p></div><a class="article-more button is-small is-size-7" href="/post/b4ed848b.html#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2018-03-22T09:52:26.000Z" title="2018-3-22 17:52:26">2018-03-22</time>发表</span><span class="level-item"><time dateTime="2020-03-06T15:29:01.028Z" title="2020-3-6 23:29:01">2020-03-06</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java-Web/">Java Web</a><span> / </span><a class="link-muted" href="/categories/Java-Web/Web/">Web</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/post/dfdfe2eb.html">Java Web（二）JavaServer Pages （JSP） </a></h1><div class="content"><p>我们知道，Servlet 中可以对客户端发来的信息进行处理（doGet、doPost等），可是，在 Servlet 里面输出 HTML 代码是一件很酸爽的事情。</p>
<p>如果我们直接写 HTML 代码，然后在需要动态获取的地方用 Java 代码来实现，不是很方便？</p>
<p>JSP 就是干这个事的！</p>
<p>维基百科定义: JSP（全称JavaServer Pages）是由Sun Microsystems公司主导建立的一种动态网页技术标准。 JSP部署于网络服务器上，可以响应客户端发送的请求，并根据请求内容动态地生成HTML、XML或其他格式文档的Web网页，然后返回给请求者。</p></div><a class="article-more button is-small is-size-7" href="/post/dfdfe2eb.html#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2018-03-20T09:59:50.000Z" title="2018-3-20 17:59:50">2018-03-20</time>发表</span><span class="level-item"><time dateTime="2020-06-14T03:44:19.993Z" title="2020-6-14 11:44:19">2020-06-14</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a><span> / </span><a class="link-muted" href="/categories/Java/Java-SE/">Java SE</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/post/f07211ef.html">Java简明笔记（十三）JDBC</a></h1><div class="content"><p>假设电脑已经安装有 MySQL，并在里面有一些表。现在，我们想通过 Java，来访问数据库里的表。</p>
<p>JDBC (Java DataBase Connection) 指的就是通过Java访问数据库。</p>
<p>这是我的数据库情况。</p>
<p><img src="../../../../images/Java/JDBC.png"></p></div><a class="article-more button is-small is-size-7" href="/post/f07211ef.html#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2018-03-11T02:44:18.000Z" title="2018-3-11 10:44:18">2018-03-11</time>发表</span><span class="level-item"><time dateTime="2020-03-06T15:24:21.218Z" title="2020-3-6 23:24:21">2020-03-06</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a><span> / </span><a class="link-muted" href="/categories/Java/Java-SE/">Java SE</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/post/779c6006.html">Java简明笔记（十二） IO编程</a></h1><div class="content"><h1 id="文件对象-File"><a href="#文件对象-File" class="headerlink" title="文件对象 File"></a>文件对象 File</h1><p>用过 Linux 的一定知道，“一切皆文件”和“一切皆文本流”的思想。在 Java 中，普通文件和文件夹都是文件对象，用<code>File</code>表示。</p></div><a class="article-more button is-small is-size-7" href="/post/779c6006.html#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2018-03-04T15:43:38.000Z" title="2018-3-4 23:43:38">2018-03-04</time>发表</span><span class="level-item"><time dateTime="2020-08-28T14:13:43.792Z" title="2020-8-28 22:13:43">2020-08-28</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java-Web/">Java Web</a><span> / </span><a class="link-muted" href="/categories/Java-Web/Web/">Web</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/post/d697e4e7.html">Java Web（一）web容器和Servlet</a></h1><div class="content"><p>在聊 Servlet 之前，先讲讲什么是 Web服务器 和 应用服务器。</p>
<h1 id="Web服务器"><a href="#Web服务器" class="headerlink" title="Web服务器"></a>Web服务器</h1><p>无论何种 Web 资源，想被远程计算机访问，都必须有一个与之对应的网络通信程序，当用户来访问时，这个网络通信程序读取 Web 资源数据，并把数据发送给来访者。</p>
<p><img src="../../../../images/Webapp/webServer.png"></p></div><a class="article-more button is-small is-size-7" href="/post/d697e4e7.html#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2018-02-28T16:29:51.000Z" title="2018-3-1 0:29:51">2018-03-01</time>发表</span><span class="level-item"><time dateTime="2020-03-06T15:24:00.553Z" title="2020-3-6 23:24:00">2020-03-06</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a><span> / </span><a class="link-muted" href="/categories/Java/Java-SE/">Java SE</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/post/727d207c.html">Java简明笔记（十一）并发编程</a></h1><div class="content"><p>关于并发的理论基础，见另一篇 <a href="../post/3bdfeb29.html">聊聊并发和并发模型</a></p>
<hr>
<h1 id="在-Java-中创建线程"><a href="#在-Java-中创建线程" class="headerlink" title="在 Java 中创建线程"></a>在 Java 中创建线程</h1><p>在 Java 中，线程是 java.lang.Thread 或其子类中的实例。通过 new 一个线程实例并调用 start 方法来启动线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread thread = <span class="keyword">new</span> Thread();</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>

<p>但是我们总得指定线程做一些事，可以用两种方式来指定。</p></div><a class="article-more button is-small is-size-7" href="/post/727d207c.html#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2018-02-27T07:06:51.000Z" title="2018-2-27 15:06:51">2018-02-27</time>发表</span><span class="level-item"><time dateTime="2020-03-06T15:24:25.979Z" title="2020-3-6 23:24:25">2020-03-06</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a><span> / </span><a class="link-muted" href="/categories/Java/Java-SE/">Java SE</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/post/85d8e3e2.html">Java简明笔记（十） 输入与输出</a></h1><div class="content"><h1 id="文本输入和输出"><a href="#文本输入和输出" class="headerlink" title="文本输入和输出"></a>文本输入和输出</h1><h2 id="文本输入"><a href="#文本输入" class="headerlink" title="文本输入"></a>文本输入</h2><p>对于较短的文本，我们可以直接把文本存到一个String里</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 整个文本</span></span><br><span class="line">String contents = <span class="keyword">new</span> String(readAllBytes((Paths.get(<span class="string">&quot;alice.txt&quot;</span>))), StandardCharsets.UTF_8);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以非字母为分隔符，变成一个个单词</span></span><br><span class="line">List&lt;String&gt; words = Arrays.asList(contents.split(<span class="string">&quot;\\PL+&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>如果想按行读取，可以读文件并存到 List 集合里，集合的每一个元素代表每一行的一个String</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按行读取</span></span><br><span class="line">List&lt;String&gt; lines = Files.readAllLines(path, charset);</span><br></pre></td></tr></table></figure></div><a class="article-more button is-small is-size-7" href="/post/85d8e3e2.html#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2018-02-25T16:07:29.000Z" title="2018-2-26 0:07:29">2018-02-26</time>发表</span><span class="level-item"><time dateTime="2020-05-07T14:52:44.252Z" title="2020-5-7 22:52:44">2020-05-07</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a><span> / </span><a class="link-muted" href="/categories/Java/Java-SE/">Java SE</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/post/372345f.html">Java简明笔记（九）Stream API</a></h1><div class="content"><h1 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h1><p>Java 中的 Stream 提供了数据源，让你可以在比集合类更高的概念层上指定操作。<strong>使用 Stream，只需要指定做什么，而不是怎么做</strong>。你只需要将操作的调度执行留给实现。</p>
<p>简单地说，流就是一组数据，经过某种操作，产生我们所需的新流，或者输出成非流数据。</p>
<p>流的来源，可以是集合，数组，I/O channel， 生成器（generator）等。流的聚合操作类似 SQL 语句，比如filter, map, reduce, find, match, sorted等。</p>
<p>例如，从文件从获取流：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (Stream&lt;String&gt; lines = Files.lines(Paths.get(<span class="string">&quot;/path/to/file.txt&quot;</span>))) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><a class="article-more button is-small is-size-7" href="/post/372345f.html#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2018-02-25T08:55:10.000Z" title="2018-2-25 16:55:10">2018-02-25</time>发表</span><span class="level-item"><time dateTime="2020-09-12T08:05:52.273Z" title="2020-9-12 16:05:52">2020-09-12</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a><span> / </span><a class="link-muted" href="/categories/Java/Java-SE/">Java SE</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/post/68278ec8.html">Java简明笔记（八）Lambda和函数式编程</a></h1><div class="content"><h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><p>我们平时所采用的 <strong>命令式编程</strong>（OO也是命令式编程的一种）关心解决问题的步骤。你要做什么事情，你得把达到目的的步骤详细的描述出来，然后交给机器去运行。</p>
<p>而函数式编程关心数据的映射，或者说，关心类型（代数结构）之间的关系。这里的映射就是数学上“函数”的概念，即一种东西和另一种东西之间的对应关系。<strong>所以，函数式编程的“函数”，是数学上的“函数”（映射），而不是编程语言中的函数或方法</strong>。</p>
<p>函数式编程的思维就是如何将这个关系组合起来，用数学的构造主义将其构造出你设计的程序。用计算来表示程序，用计算的组合来表达程序的组合。</p></div><a class="article-more button is-small is-size-7" href="/post/68278ec8.html#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2018-02-05T16:03:34.000Z" title="2018-2-6 0:03:34">2018-02-06</time>发表</span><span class="level-item"><time dateTime="2020-03-06T15:24:34.615Z" title="2020-3-6 23:24:34">2020-03-06</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a><span> / </span><a class="link-muted" href="/categories/Java/Java-SE/">Java SE</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/post/a3bb075d.html">Java简明笔记（七） 异常和断言</a></h1><div class="content"><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>在Java异常处理中，一个方法可以通过 <strong>抛出(throw)</strong> 异常来发出一个严重问题的信号。调用链中的某个方法，负责 <strong>捕获（catch）</strong> 并处理异常。捕获到的异常不仅可以在当前方法中处理，还可以将异常抛给调用它的上一级方法去处理。</p>
<p>异常处理的根本优点是：将错误检测和错误处理的过程解耦。</p>
<p>Java 的异常都派生自 Throwable 类，Throwable 又分为 Error 和 Exception。Error 不是我们的程序所能够处理的，比如系统内存耗尽。我们能预知并处理的错误属于 Exception。Exception又分为 unchecked exception 和 checked exception。 unchecked exception 属于 RuntimeException 。</p>
<blockquote>
<p>当然，所有的异常都发生在运行时（Runtime），但是 RuntimeException 派生的子类异常在编译时不会被检查。</p>
</blockquote>
<p><img src="../../../../images/Java/Throwable.png"></p></div><a class="article-more button is-small is-size-7" href="/post/a3bb075d.html#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2018-02-04T16:27:20.000Z" title="2018-2-5 0:27:20">2018-02-05</time>发表</span><span class="level-item"><time dateTime="2020-03-06T15:26:13.368Z" title="2020-3-6 23:26:13">2020-03-06</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a><span> / </span><a class="link-muted" href="/categories/Java/Java-SE/">Java SE</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/post/689b9445.html">Java中的 String</a></h1><div class="content"><h1 id="String-的本质"><a href="#String-的本质" class="headerlink" title="String 的本质"></a>String 的本质</h1><p>在 Java8 中，分析 java.lang.String 类的源码，可以发现 String 内部维护的是一个 char 数组。同时可以发现，String类被 <code>final</code> 修饰，即不可变的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Java9 中，将 char 数组优化成了 byte 数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span> value[];</span><br></pre></td></tr></table></figure></div><a class="article-more button is-small is-size-7" href="/post/689b9445.html#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2018-02-04T14:43:40.000Z" title="2018-2-4 22:43:40">2018-02-04</time>发表</span><span class="level-item"><time dateTime="2021-05-12T14:27:13.273Z" title="2021-5-12 22:27:13">2021-05-12</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a><span> / </span><a class="link-muted" href="/categories/Java/Java-SE/">Java SE</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/post/f85bb872.html">Java简明笔记（六） 集合</a></h1><div class="content"><h1 id="集合和集合框架"><a href="#集合和集合框架" class="headerlink" title="集合和集合框架"></a>集合和集合框架</h1><h2 id="什么是集合？"><a href="#什么是集合？" class="headerlink" title="什么是集合？"></a>什么是集合？</h2><p>集合就是一个放数据的容器，准确的说是放数据对象引用的容器。</p>
<p>Java集合主要可以划分为三个部分：</p>
<ol>
<li>Collection（包含 List 和 Set ）</li>
<li>Map （键值对）</li>
<li>工具类（Iterator迭代器、Enumeration枚举类、Arrays和VCollections）</li>
</ol></div><a class="article-more button is-small is-size-7" href="/post/f85bb872.html#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2018-01-24T08:59:55.000Z" title="2018-1-24 16:59:55">2018-01-24</time>发表</span><span class="level-item"><time dateTime="2020-08-22T10:27:39.882Z" title="2020-8-22 18:27:39">2020-08-22</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a><span> / </span><a class="link-muted" href="/categories/Java/Java-SE/">Java SE</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/post/76bad10f.html">Java简明笔记（五） 泛型编程</a></h1><div class="content"><h1 id="什么是泛型类"><a href="#什么是泛型类" class="headerlink" title="什么是泛型类"></a>什么是泛型类</h1><p>假设我们现在有一个存储字符串字典键值对的类，就像这样</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数：int 类型的 key， String 类型的 value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Entry</span><span class="params">(<span class="keyword">int</span> key, String value)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.key = key;</span><br><span class="line">      <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getKey</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个类中，我们用 int 类型来存储 key 值， 用 String 类型来存储 value 值。</p>
<p>现在，老板要求，除了 int 类型的 key 和 String 类型的 value之外，还得提供其他类型的 key 和 value 。 比如 double 类型的 key， boolean 类型的value。</p>
<p>我们不可能写很多个相似的类，只是换一下类型。8种基本数据类型或许可以这么干，但是存储的是抽象数据类型呢？我们不可能所有类型都写一个对应的类。</p>
<p>为了解决这个问题，我们可以用 Java 泛型： 只写一个类，实例化的时候再写明是什么类型就好了。这就是泛型类。</p>
<blockquote>
<p>泛型仅仅是java的语法糖，它不会影响java虚拟机生成的汇编代码，在编译阶段，虚拟机就会把泛型的类型擦除，还原成没有泛型的代码。</p>
</blockquote></div><a class="article-more button is-small is-size-7" href="/post/76bad10f.html#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2018-01-23T10:14:26.000Z" title="2018-1-23 18:14:26">2018-01-23</time>发表</span><span class="level-item"><time dateTime="2020-03-06T15:23:56.305Z" title="2020-3-6 23:23:56">2020-03-06</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a><span> / </span><a class="link-muted" href="/categories/Java/Java-SE/">Java SE</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/post/2fJava80.html">Java简明笔记（四） 继承</a></h1><div class="content"><h1 id="什么是继承"><a href="#什么是继承" class="headerlink" title="什么是继承"></a>什么是继承</h1><p>继承是在现有的类的基础上创建新类的过程。继承一个类，你也就重用了它的方法，而且还可以添加新的方法和域。</p>
<p>举个例子：员工有薪水，管理者有薪水+奖金， 管理者继承员工，增加 bounus 字段和 setBonus 方法即可。这种情况就是管理者类继承了员工类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> bonus;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBonus</span> <span class="params">(<span class="keyword">double</span> bouns)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.bonus = bonus;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Manager</code>类继承了<code>Employee</code>类，除了获得Employee类的变量和方法外，还额外添加了bonus变量和setBonus方法。</p></div><a class="article-more button is-small is-size-7" href="/post/2fJava80.html#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2018-01-20T14:27:27.000Z" title="2018-1-20 22:27:27">2018-01-20</time>发表</span><span class="level-item"><time dateTime="2020-03-06T15:24:30.770Z" title="2020-3-6 23:24:30">2020-03-06</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a><span> / </span><a class="link-muted" href="/categories/Java/Java-SE/">Java SE</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/post/32811f1d.html">Java简明笔记（三） 接口</a></h1><div class="content"><h1 id="什么是接口"><a href="#什么是接口" class="headerlink" title="什么是接口"></a>什么是接口</h1><p>假设有一种整数序列服务，这种服务可以计算前n个整数的平均值。就像这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">average</span><span class="params">(IntSequence seq, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> average</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们传入一个序列seq，以及我们想计算这个序列的前n个数，它返回平均数。</p>
<p>然而，这样的序列可以有很多种形式，比如用户给出的序列、随机数序列、素数序列、整数数组中的元素序列……</p></div><a class="article-more button is-small is-size-7" href="/post/32811f1d.html#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2018-01-18T14:31:07.000Z" title="2018-1-18 22:31:07">2018-01-18</time>发表</span><span class="level-item"><time dateTime="2020-03-06T15:24:45.867Z" title="2020-3-6 23:24:45">2020-03-06</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a><span> / </span><a class="link-muted" href="/categories/Java/Java-SE/">Java SE</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/post/ba7990ce.html">Java简明笔记（二） 面向对象</a></h1><div class="content"><h1 id="Java-创建对象的过程"><a href="#Java-创建对象的过程" class="headerlink" title="Java 创建对象的过程"></a>Java 创建对象的过程</h1><p>当我们实例化一个对象时，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure>

<p>Java首先会在堆中开辟一块内存空间用来存放这个新的 Person 对象，然后在栈中创建一个引用 p ， p 指向堆中的 Person 对象。这样，我们通过 p 就能找到 Person 的内存地址。</p>
<p>之后，我们执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person p2 = p;</span><br></pre></td></tr></table></figure>

<p>我们创建了一个新的引用 p2， p2 跟 p 一样，都是保存在栈中，也指向了 Person 对象。当我们改变 p2 的状态， p 也会跟着改变，因为他们指向同一个对象。</p></div><a class="article-more button is-small is-size-7" href="/post/ba7990ce.html#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2017-11-05T14:40:39.000Z" title="2017-11-5 22:40:39">2017-11-05</time>发表</span><span class="level-item"><time dateTime="2020-06-14T08:12:52.591Z" title="2020-6-14 16:12:52">2020-06-14</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a><span> / </span><a class="link-muted" href="/categories/Java/Java-SE/">Java SE</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/post/b3088ac5.html">Java简明笔记（一） 基础知识</a></h1><div class="content"><p><img src="../../../../images/Java/java.jpg" alt="java"></p>
<h1 id="Java-与-C-的区别"><a href="#Java-与-C-的区别" class="headerlink" title="Java 与 C++ 的区别"></a>Java 与 C++ 的区别</h1><ol>
<li>C++支持多重继承，Java不支持，但可以实现多接口。（引申：多重继承菱形问题）</li>
<li>自动内存管理</li>
<li>java不支持goto语句</li>
<li><strong>引用与指针</strong>：在Java中不可能直接操作对象本身，所有的对象都由一个引用指向，必须通过这个引用才能访问对象本身，包括获取成员变量的值，改变对象的成员变量，调用对象的方法等。而在 C++ 中存在引用，对象和指针三个东西，这三个东西都可以访问对象。其实，Java中的引用和C++中的指针在概念上是相似的，他们都是存放的对象在内存中的地址值，只是在Java中，引用丧失了部分灵活性，比如 Java 中的引用不能像 C++ 中的指针那样进行加减运算。</li>
</ol></div><a class="article-more button is-small is-size-7" href="/post/b3088ac5.html#more">阅读更多</a></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/images/blog/ava.png" alt="Jerry Sheh"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Jerry Sheh</p><p class="is-size-6 is-block">车顶上绑着飞机发动机</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Shenzhen</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">178</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">34</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">35</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="mailto:jerrysheh@gmail.com" target="_blank" rel="noopener">联系我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/Jerrysheh"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="email" href="mailto:jerrysheh@gmail.com"><i class="fa fa-envelope"></i></a></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Android/"><span class="level-start"><span class="level-item">Android</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/categories/C-C/"><span class="level-start"><span class="level-item">C/C++</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Golang/"><span class="level-start"><span class="level-item">Golang</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">43</span></span></a><ul><li><a class="level is-mobile" href="/categories/Java/Concurrent/"><span class="level-start"><span class="level-item">Concurrent</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/Java/Effective-Java/"><span class="level-start"><span class="level-item">Effective Java</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/Java/JDBC/"><span class="level-start"><span class="level-item">JDBC</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Java/JVM/"><span class="level-start"><span class="level-item">JVM</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/Java/Java-SE/"><span class="level-start"><span class="level-item">Java SE</span></span><span class="level-end"><span class="level-item tag">20</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Java-Web/"><span class="level-start"><span class="level-item">Java Web</span></span><span class="level-end"><span class="level-item tag">15</span></span></a><ul><li><a class="level is-mobile" href="/categories/Java-Web/Spring/"><span class="level-start"><span class="level-item">Spring</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/Java-Web/Web/"><span class="level-start"><span class="level-item">Web</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/Java-Web/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"><span class="level-start"><span class="level-item">微服务</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/"><span class="level-start"><span class="level-item">Python</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"><span class="level-start"><span class="level-item">中间件</span></span><span class="level-end"><span class="level-item tag">2</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/"><span class="level-start"><span class="level-item">redis</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E5%89%8D%E7%AB%AF/"><span class="level-start"><span class="level-item">前端</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"><span class="level-start"><span class="level-item">大数据</span></span><span class="level-end"><span class="level-item tag">12</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/Scala/"><span class="level-start"><span class="level-item">Scala</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/Spark/"><span class="level-start"><span class="level-item">Spark</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/hadoop/"><span class="level-start"><span class="level-item">hadoop</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E6%8A%80%E8%83%BD/"><span class="level-start"><span class="level-item">技能</span></span><span class="level-end"><span class="level-item tag">4</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E6%8A%80%E8%83%BD/Docker/"><span class="level-start"><span class="level-item">Docker</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%8A%80%E8%83%BD/git/"><span class="level-start"><span class="level-item">git</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%8A%80%E8%83%BD/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"><span class="level-start"><span class="level-item">正则表达式</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="level-start"><span class="level-item">操作系统</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="level-start"><span class="level-item">数据库</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">数据结构和算法</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%9E%8E%E6%8A%98%E8%85%BE/"><span class="level-start"><span class="level-item">瞎折腾</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E9%80%9F%E6%88%90%E8%AF%BE/"><span class="level-start"><span class="level-item">计算机科学速成课</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><span class="level-start"><span class="level-item">计算机网络</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="level-start"><span class="level-item">设计模式</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BB%E4%B9%A6%E4%B8%8E%E7%94%9F%E6%B4%BB/"><span class="level-start"><span class="level-item">读书与生活</span></span><span class="level-end"><span class="level-item tag">14</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">推荐链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://www.wmyskxz.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">我没有三颗心脏</span></span><span class="level-right"><span class="level-item tag">www.wmyskxz.com</span></span></a></li><li><a class="level is-mobile" href="https://www.cnblogs.com/vamei/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Vamei</span></span><span class="level-right"><span class="level-item tag">www.cnblogs.com</span></span></a></li><li><a class="level is-mobile" href="https://www.celesteheadlee.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">celesteheadlee</span></span><span class="level-right"><span class="level-item tag">www.celesteheadlee.com</span></span></a></li><li><a class="level is-mobile" href="https://www.xaprb.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Baron Schwartz</span></span><span class="level-right"><span class="level-item tag">www.xaprb.com</span></span></a></li><li><a class="level is-mobile" href="http://tutorials.jenkov.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">jenkov</span></span><span class="level-right"><span class="level-item tag">tutorials.jenkov.com</span></span></a></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/images/blog/logo.png" alt="J.e" height="28"></a><p class="is-size-7"><span>&copy; 2021 Jerry Sheh</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>