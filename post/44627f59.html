<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Java简明笔记（十五）Java NIO - J.e</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="J.e"><meta name="msapplication-TileImage" content="/images/blog/avatar.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="J.e"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="什么是 Java NIOJava NIO， N 可以理解为 New ，也可以理解为 Non-blocking ，是 Java 1.4 之后新的一套区别于标准 Java IO 和 Java Networking 的 API 。NIO 跟传统的 BIO 之间最大的区别在于 NIO 是面向 Channels 和 Buffers 的，一个线程可以通过 Selector 管理多个 Channels ，继而管"><meta property="og:type" content="blog"><meta property="og:title" content="Java简明笔记（十五）Java NIO"><meta property="og:url" content="https://jerrysheh.me/post/44627f59.html"><meta property="og:site_name" content="J.e"><meta property="og:description" content="什么是 Java NIOJava NIO， N 可以理解为 New ，也可以理解为 Non-blocking ，是 Java 1.4 之后新的一套区别于标准 Java IO 和 Java Networking 的 API 。NIO 跟传统的 BIO 之间最大的区别在于 NIO 是面向 Channels 和 Buffers 的，一个线程可以通过 Selector 管理多个 Channels ，继而管"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://jerrysheh.me/images/Java/channel_buffer.png"><meta property="og:image" content="https://jerrysheh.me/images/Java/buffers-modes.png"><meta property="og:image" content="https://jerrysheh.me/images/Java/compact.png"><meta property="og:image" content="https://jerrysheh.me/images/Java/Scatter_Gather.png"><meta property="og:image" content="https://jerrysheh.me/images/Java/overview-selectors.png"><meta property="article:published_time" content="2018-09-07T12:47:06.000Z"><meta property="article:modified_time" content="2020-03-30T15:02:46.082Z"><meta property="article:author" content="Jerry Sheh"><meta property="article:tag" content="Java"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="../../../../images/Java/channel_buffer.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://jerrysheh.me/post/44627f59.html"},"headline":"J.e","image":["https://jerrysheh.me/images/Java/channel_buffer.png","https://jerrysheh.me/images/Java/buffers-modes.png","https://jerrysheh.me/images/Java/compact.png","https://jerrysheh.me/images/Java/Scatter_Gather.png","https://jerrysheh.me/images/Java/overview-selectors.png"],"datePublished":"2018-09-07T12:47:06.000Z","dateModified":"2020-03-30T15:02:46.082Z","author":{"@type":"Person","name":"Jerry Sheh"},"description":"什么是 Java NIOJava NIO， N 可以理解为 New ，也可以理解为 Non-blocking ，是 Java 1.4 之后新的一套区别于标准 Java IO 和 Java Networking 的 API 。NIO 跟传统的 BIO 之间最大的区别在于 NIO 是面向 Channels 和 Buffers 的，一个线程可以通过 Selector 管理多个 Channels ，继而管"}</script><link rel="canonical" href="https://jerrysheh.me/post/44627f59.html"><link rel="icon" href="/images/blog/avatar.png"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.13.1/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><!--!--><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/images/blog/logo.png" alt="J.e" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">时间线</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/about">关于</a><a class="navbar-item" href="/sentences">醍醐灌顶</a><a class="navbar-item" href="/anpu">Anpu</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2018-09-07T12:47:06.000Z" title="2018-9-7 20:47:06">2018-09-07</time>发表</span><span class="level-item"><time dateTime="2020-03-30T15:02:46.082Z" title="2020-3-30 23:02:46">2020-03-30</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a><span> / </span><a class="link-muted" href="/categories/Java/Java-SE/">Java SE</a></span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">Java简明笔记（十五）Java NIO</h1><div class="content"><h1 id="什么是-Java-NIO"><a href="#什么是-Java-NIO" class="headerlink" title="什么是 Java NIO"></a>什么是 Java NIO</h1><p>Java NIO， N 可以理解为 New ，也可以理解为 Non-blocking ，是 Java 1.4 之后新的一套区别于标准 Java IO 和 Java Networking 的 API 。NIO 跟传统的 BIO 之间最大的区别在于 NIO 是面向 Channels 和 Buffers 的，一个线程可以通过 Selector 管理多个 Channels ，继而管理多个连接，在线程进行 IO 操作时不会阻塞。</p>
<span id="more"></span>

<h1 id="面向-Channels-和-Buffers"><a href="#面向-Channels-和-Buffers" class="headerlink" title="面向 Channels 和 Buffers"></a>面向 Channels 和 Buffers</h1><p>普通的IO，面向的是 byte streams（字节流，如FileOutputStream） 和 character streams（字符流，如FileReader），但是 NIO 面向的是 channels 和 buffers 。对于 Channel 来说，数据总是从 channel 写进 buffer 里，然后 Java 从 buffer 取出使用，或者 channel 读 buffer 里的数据，传输到外界。</p>
<p><img src="../../../../images/Java/channel_buffer.png" alt="channel_buffer"></p>
<p>Channel 有点像流（Stream），在 Java NIO 中，有以下几种 channel：</p>
<ul>
<li>FileChannel</li>
<li>DatagramChannel （用于通过 UDP 读写数据）</li>
<li>SocketChannel （用于通过 TCP 读写数据）</li>
<li>ServerSocketChannel</li>
</ul>
<p>而 Buffer 就是我们熟悉的缓冲区了。包括：</p>
<ul>
<li>ByteBuffer</li>
<li>CharBuffer</li>
<li>DoubleBuffer</li>
<li>FloatBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>ShortBuffer</li>
<li>MappedByteBuffer（不展开讲）</li>
</ul>
<p>一个线程，可以让 channel 把数据读进 buffer 中（操作者是 channel ），当 channel 正在读的时候，线程可以做其他事。一旦数据已经读进 buffer 了，线程可以回来处理这些数据。写的情况也是类似。</p>
<h2 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h2><p>Channel 和 Buffer 配合的工作流程如下：</p>
<ol>
<li>开一个文件</li>
<li>获取 Channel</li>
<li>设置 buffer</li>
<li>让 Channel 将数据读到 buffer 里</li>
<li>数据进入 buffer</li>
<li>调用 <code>buffer.flip()</code></li>
<li>数据从 buffer 出去</li>
<li>调用 <code>buffer.clear()</code> 或 b<code>uffer.compact()</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RandomAccessFile 可以自由读写文件的任意位置，不继承字节流或字符流</span></span><br><span class="line"><span class="comment">// 1. 开一个文件</span></span><br><span class="line">RandomAccessFile aFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;data/nio-data.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 获取 Channel</span></span><br><span class="line">FileChannel inChannel = aFile.getChannel();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 设置 buffer，由于我们要读字节，因此是 ByteBuffer</span></span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 利用 Channel 将数据读到 buffer 里</span></span><br><span class="line"><span class="keyword">int</span> bytesRead = inChannel.read(buf);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (bytesRead != -<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;Read &quot;</span> + bytesRead);</span><br><span class="line">    buf.flip();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(buf.hasRemaining())&#123;</span><br><span class="line">        System.out.print((<span class="keyword">char</span>) buf.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buf.clear();</span><br><span class="line">    bytesRead = inChannel.read(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">aFile.close();</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li><code>buf.flip()</code> 的作用：当你想从 buffer 里获取数据，应该调用 flip 方法。调用这个方法的时候，buffer 将会从 数据写入模式 切换到 数据读出模式</li>
<li><code>buf.clear()</code>的作用：当数据全部从 buffer 读出去了，应该调用 clear 或 compact 方法，好让 buffer 重写可以写入。 这两个方法的区别是：clear清除整个缓冲区，compact只清除已经读过的部分。</li>
</ul>
<hr>
<h2 id="Capacity-Position-和-Limit"><a href="#Capacity-Position-和-Limit" class="headerlink" title="Capacity, Position 和 Limit"></a>Capacity, Position 和 Limit</h2><p>buffer 实际上是一块内存区域可以让你往里面写数据，之后再读到程序里。这块内存区域包含在一个 NIO Buffer 对象里。</p>
<p>在 buffer 中，有 Capacity, Position 和 Limit 这三个概念。position 跟 limit 跟 buffer 是读模式还是写模式有关，而 Capacity 与模式无关。</p>
<p><img src="../../../../images/Java/buffers-modes.png" alt="selectors"></p>
<h3 id="Capacity"><a href="#Capacity" class="headerlink" title="Capacity"></a>Capacity</h3><p>顾名思义，Capacity 就是容量。也就是 buffer 缓冲区最多能存储多少 bytes （或者 longs，或 chars ，取决于何种类型的 buffer ）</p>
<h3 id="Position"><a href="#Position" class="headerlink" title="Position"></a>Position</h3><p>当你往 buffer 里写一个单位的数据的时候， position 就 +1， position是当前位置指示器。最大值为 Capacity - 1。</p>
<p>当你从 buffer 里读数据时，同样有一个 position 指示器。当调用 flip ，让 buffer 从写模式转换成读模式的时候， position 会被重置为 0</p>
<h3 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h3><p>在 buffer 写模式中， limit 等于 capacity，决定了你能往 buffer 里写多少数据。</p>
<p>在 buffer 读模式中，limit 告诉你缓冲取最多有多少数据可以让你读取。也就是说，一开始写模式写了多少数据，会记录在 position 中，一旦你调用 flip 切换到读模式，limit 就是刚刚的 position。</p>
<hr>
<h2 id="Buffer-的方法"><a href="#Buffer-的方法" class="headerlink" title="Buffer 的方法"></a>Buffer 的方法</h2><h3 id="flip"><a href="#flip" class="headerlink" title="flip"></a>flip</h3><p>当调用 flip方法， position 会被置0，然后 buffer 会切换模式（读-&gt;写，或 写-&gt;读），limit 也随之改变。</p>
<h3 id="rewind"><a href="#rewind" class="headerlink" title="rewind"></a>rewind</h3><p>rewind 可以让 position 变为 0， 好让你重新读刚刚读过的数据，但是模式不变。limit 的值也不会变。</p>
<h3 id="clear-和-compact"><a href="#clear-和-compact" class="headerlink" title="clear() 和 compact()"></a>clear() 和 compact()</h3><p>clear清除整个缓冲区，compact只清除已经读过的部分。如果你有一些数据还没读，使用 compact， compact 会把未读的数据放到起始位置，然后把 position 放到最后一个数据的右边。</p>
<p><img src="../../../../images/Java/compact.png" alt="selectors"></p>
<h3 id="mark-和-reset"><a href="#mark-和-reset" class="headerlink" title="mark() 和 reset()"></a>mark() 和 reset()</h3><p>可以用 mark 方法标记 position，然后做一个其他事后，调用 reset， position 会回到刚刚标记的位置。</p>
<hr>
<h2 id="Scatter（分散）-Gather（聚集）"><a href="#Scatter（分散）-Gather（聚集）" class="headerlink" title="Scatter（分散） / Gather（聚集）"></a>Scatter（分散） / Gather（聚集）</h2><p><strong>channel “scatters” 是指，多个 buffer 从一个 Channel 里读取数据</strong>。分散读取是以数组的形式，总是先填充前面的 buffer，这意味着不支持动态大小。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer header = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">ByteBuffer body   = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">ByteBuffer[] bufferArray = &#123; header, body &#125;;</span><br><span class="line"></span><br><span class="line">channel.read(bufferArray);</span><br></pre></td></tr></table></figure>

<p><img src="../../../../images/Java/Scatter_Gather.png" alt="Scatter_Gather"></p>
<p><strong>channel “gathers” 是指，多个 buffer 把数据写进一个 Channel</strong>。如果一个 <code>ByteBuffer</code> 的 capacity 有128字节，但实际只存储了58字节。Gather 只会往 channel 里写这58字节。然后继续写下一个。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer header = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">ByteBuffer body   = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//write data into buffers</span></span><br><span class="line"></span><br><span class="line">ByteBuffer[] bufferArray = &#123; header, body &#125;;</span><br><span class="line"></span><br><span class="line">channel.write(bufferArray);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="在不同-Channel-之间转换"><a href="#在不同-Channel-之间转换" class="headerlink" title="在不同 Channel 之间转换"></a>在不同 Channel 之间转换</h2><p>Channel 之间可以互相转换，以 FileChannel 为例，提供了 <code>transferFrom()</code> 和 <code>transferTo()</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile fromFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;fromFile.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">FileChannel      fromChannel = fromFile.getChannel();</span><br><span class="line"></span><br><span class="line">RandomAccessFile toFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;toFile.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">FileChannel      toChannel = toFile.getChannel();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> position = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> count    = fromChannel.size();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从其他channle转到FileChannel</span></span><br><span class="line">toChannel.transferFrom(fromChannel, position, count);</span><br><span class="line"><span class="comment">// 从FileChannel转到其他channle</span></span><br><span class="line">fromChannel.transferTo(position, count, toChannel);</span><br></pre></td></tr></table></figure>

<p>在有些 <code>SocketChannel</code> 的实现中，只会转换 channel 当前有的数据（尽管稍后 SocketChannel 会传来更多数据，但会被忽略）</p>
<hr>
<h1 id="Selectors"><a href="#Selectors" class="headerlink" title="Selectors"></a>Selectors</h1><p>Java NIO 有一个 “selectors” 的概念。 selector 可以监控多个 channels 事件的状态（例如，连接已建立，数据已到达等）。因此，只需一个线程即可管理多个 channels ，继而管理多个 connection。在并发量特别大时，传统的IO由于一个线程只负责一个连接，因此会创建大量线程。而用 NIO 的 selector，你甚至可以只用一个线程管理所有连接。</p>
<p>然而，不要一贯认为传统IO多线程就不好。我们总说操作系统在线程切换时有一定开销，然而现代CPU都是多核处理器，不用多线程相当于浪费。</p>
<p><img src="../../../../images/Java/overview-selectors.png" alt="selectors"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">第二个参数设置感兴趣的事件，可选项：</span></span><br><span class="line"><span class="comment">SelectionKey.OP_CONNECT</span></span><br><span class="line"><span class="comment">SelectionKey.OP_ACCEPT</span></span><br><span class="line"><span class="comment">SelectionKey.OP_READ</span></span><br><span class="line"><span class="comment">SelectionKey.OP_WRITE</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三个参数设置附加对象（可选）</span></span><br><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ, theObject);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>使用 Selectors 的 channel 必须设置成 non-blocking 模式</strong>。FileChannel 无法设置成 non-blocking 因此无法使用 Selectors。 Socketchannels 则可以。<code>channel.register</code> 的第二个参数设定感兴趣的事件，如连接已建立、客户端accept，准备好可读，准备好可写。如果需要设定多个使用，用或语句。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure>

<p>register 之后会返回一个 <code>SelectionKey</code>，通过它来获取有用信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Channel  channel  = selectionKey.channel();</span><br><span class="line"></span><br><span class="line">Selector selector = selectionKey.selector();    </span><br><span class="line"></span><br><span class="line"><span class="comment">// 附加对象（可选）</span></span><br><span class="line">selectionKey.attach(theObject);</span><br><span class="line"></span><br><span class="line">Object attachedObj = selectionKey.attachment();</span><br></pre></td></tr></table></figure>

<h2 id="select-方法"><a href="#select-方法" class="headerlink" title="select 方法"></a>select 方法</h2><p>Selectors 的 <code>select()</code>方法用于返回准备好的 channel 数量。例如，你设置了若干个 SocketChannel 对 read 感兴趣。当你调用 <code>select()</code> ，将返回当前准备好可以读取数据的 channel 数量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">()</span> <span class="comment">// 若无，则阻塞</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="comment">// 若无，超时时间内阻塞</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">selectNow</span><span class="params">()</span> <span class="comment">// 立即返回</span></span></span><br></pre></td></tr></table></figure>

<p>当 select 返回大于0的数字，说明有 channel 准备好了，实际上内容封装在 <code>Set&lt;SelectionKey&gt;</code> 里，我们可以取出来然后做相应的动作。完整例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line">channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> readyChannels = selector.selectNow();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(readyChannels == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line"></span><br><span class="line">  Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(keyIterator.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">    SelectionKey key = keyIterator.next();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(key.isAcceptable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was accepted by a ServerSocketChannel.</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isConnectable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was established with a remote server.</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for reading</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for writing</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    keyIterator.remove();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="wakeup-和-close"><a href="#wakeup-和-close" class="headerlink" title="wakeup() 和 close()"></a>wakeup() 和 close()</h2><p>调用 <code>select()</code> 方法的线程会阻塞，用另一个线程调用 <code>Selector.wakeup()</code> 方法可以让它立即返回。</p>
<p>调用<code>Selector.close()</code>可以关闭 Selector 和所有 SelectionKey ，但 channels 不会被关闭。</p>
<hr>
<h1 id="什么时候用-NIO，什么时候用传统-IO-？"><a href="#什么时候用-NIO，什么时候用传统-IO-？" class="headerlink" title="什么时候用 NIO，什么时候用传统 IO ？"></a>什么时候用 NIO，什么时候用传统 IO ？</h1><p>NIO可以只使用一个（或几个）单线程管理多个通道（网络连接或文件），但付出的代价是解析数据可能会比从一个阻塞流中读取数据更复杂。</p>
<p>如果需要管理同时打开的成千上万个连接，这些连接每次只是发送少量的数据，例如聊天服务器，实现NIO的服务器可能是一个优势。同样，如果你需要维持许多打开的连接到其他计算机上，如P2P网络中，使用一个单独的线程来管理你所有出站连接，NIO可能是一个优势。</p>
<p>如果你只有少量的连接但是每个连接都占有很高的带宽，同时发送很多数据，传统的IO会更适合。</p>
<hr>
<ul>
<li>参考教程：<a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-nio">java-nio</a></li>
</ul>
</div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Java/">Java</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/post/4c81d70.html"><i class="level-item fas fa-chevron-left"></i><span class="level-item">数据库（二）存储引擎、事务、锁</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/post/fd9d3113.html"><span class="level-item">使用 JWT 进行认证</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/%5Cimages%5Cblog%5Cavatar.png" alt="Jerry Sheh"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Jerry Sheh</p><p class="is-size-6 is-block">车顶上绑着飞机发动机</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Shenzhen</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">177</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">31</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">35</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="mailto:jerrysheh@gmail.com" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/Jerrysheh"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="email" href="mailto:jerrysheh@gmail.com"><i class="fa fa-envelope"></i></a></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Android/"><span class="level-start"><span class="level-item">Android</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/categories/C-C/"><span class="level-start"><span class="level-item">C/C++</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Golang/"><span class="level-start"><span class="level-item">Golang</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">43</span></span></a><ul><li><a class="level is-mobile" href="/categories/Java/Concurrent/"><span class="level-start"><span class="level-item">Concurrent</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/Java/Effective-Java/"><span class="level-start"><span class="level-item">Effective Java</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/Java/JDBC/"><span class="level-start"><span class="level-item">JDBC</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Java/JVM/"><span class="level-start"><span class="level-item">JVM</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/Java/Java-SE/"><span class="level-start"><span class="level-item">Java SE</span></span><span class="level-end"><span class="level-item tag">20</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Java-Web/"><span class="level-start"><span class="level-item">Java Web</span></span><span class="level-end"><span class="level-item tag">15</span></span></a><ul><li><a class="level is-mobile" href="/categories/Java-Web/Spring/"><span class="level-start"><span class="level-item">Spring</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/Java-Web/Web/"><span class="level-start"><span class="level-item">Web</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/Java-Web/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"><span class="level-start"><span class="level-item">微服务</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/"><span class="level-start"><span class="level-item">Python</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"><span class="level-start"><span class="level-item">中间件</span></span><span class="level-end"><span class="level-item tag">2</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/"><span class="level-start"><span class="level-item">redis</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E5%89%8D%E7%AB%AF/"><span class="level-start"><span class="level-item">前端</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"><span class="level-start"><span class="level-item">大数据</span></span><span class="level-end"><span class="level-item tag">12</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/Scala/"><span class="level-start"><span class="level-item">Scala</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/Spark/"><span class="level-start"><span class="level-item">Spark</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/hadoop/"><span class="level-start"><span class="level-item">hadoop</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E6%8A%80%E8%83%BD/"><span class="level-start"><span class="level-item">技能</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="level-start"><span class="level-item">操作系统</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="level-start"><span class="level-item">数据库</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">数据结构和算法</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%9E%8E%E6%8A%98%E8%85%BE/"><span class="level-start"><span class="level-item">瞎折腾</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E9%80%9F%E6%88%90%E8%AF%BE/"><span class="level-start"><span class="level-item">计算机科学速成课</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><span class="level-start"><span class="level-item">计算机网络</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="level-start"><span class="level-item">设计模式</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BB%E4%B9%A6%E4%B8%8E%E7%94%9F%E6%B4%BB/"><span class="level-start"><span class="level-item">读书与生活</span></span><span class="level-end"><span class="level-item tag">14</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#什么是-Java-NIO"><span class="level-left"><span class="level-item">1</span><span class="level-item">什么是 Java NIO</span></span></a></li><li><a class="level is-mobile" href="#面向-Channels-和-Buffers"><span class="level-left"><span class="level-item">2</span><span class="level-item">面向 Channels 和 Buffers</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#一个简单的例子"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">一个简单的例子</span></span></a></li><li><a class="level is-mobile" href="#Capacity-Position-和-Limit"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">Capacity, Position 和 Limit</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Capacity"><span class="level-left"><span class="level-item">2.2.1</span><span class="level-item">Capacity</span></span></a></li><li><a class="level is-mobile" href="#Position"><span class="level-left"><span class="level-item">2.2.2</span><span class="level-item">Position</span></span></a></li><li><a class="level is-mobile" href="#limit"><span class="level-left"><span class="level-item">2.2.3</span><span class="level-item">limit</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Buffer-的方法"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">Buffer 的方法</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#flip"><span class="level-left"><span class="level-item">2.3.1</span><span class="level-item">flip</span></span></a></li><li><a class="level is-mobile" href="#rewind"><span class="level-left"><span class="level-item">2.3.2</span><span class="level-item">rewind</span></span></a></li><li><a class="level is-mobile" href="#clear-和-compact"><span class="level-left"><span class="level-item">2.3.3</span><span class="level-item">clear() 和 compact()</span></span></a></li><li><a class="level is-mobile" href="#mark-和-reset"><span class="level-left"><span class="level-item">2.3.4</span><span class="level-item">mark() 和 reset()</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Scatter（分散）-Gather（聚集）"><span class="level-left"><span class="level-item">2.4</span><span class="level-item">Scatter（分散） / Gather（聚集）</span></span></a></li><li><a class="level is-mobile" href="#在不同-Channel-之间转换"><span class="level-left"><span class="level-item">2.5</span><span class="level-item">在不同 Channel 之间转换</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Selectors"><span class="level-left"><span class="level-item">3</span><span class="level-item">Selectors</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#select-方法"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">select 方法</span></span></a></li><li><a class="level is-mobile" href="#wakeup-和-close"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">wakeup() 和 close()</span></span></a></li></ul></li><li><a class="level is-mobile" href="#什么时候用-NIO，什么时候用传统-IO-？"><span class="level-left"><span class="level-item">4</span><span class="level-item">什么时候用 NIO，什么时候用传统 IO ？</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://www.wmyskxz.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">我没有三颗心脏</span></span><span class="level-right"><span class="level-item tag">www.wmyskxz.com</span></span></a></li><li><a class="level is-mobile" href="https://www.cnblogs.com/vamei/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Vamei</span></span><span class="level-right"><span class="level-item tag">www.cnblogs.com</span></span></a></li><li><a class="level is-mobile" href="https://www.celesteheadlee.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">celesteheadlee</span></span><span class="level-right"><span class="level-item tag">www.celesteheadlee.com</span></span></a></li><li><a class="level is-mobile" href="https://www.xaprb.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Baron Schwartz</span></span><span class="level-right"><span class="level-item tag">www.xaprb.com</span></span></a></li><li><a class="level is-mobile" href="http://tutorials.jenkov.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">jenkov</span></span><span class="level-right"><span class="level-item tag">tutorials.jenkov.com</span></span></a></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/images/blog/logo.png" alt="J.e" height="28"></a><p class="is-size-7"><span>&copy; 2021 Jerry Sheh</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>