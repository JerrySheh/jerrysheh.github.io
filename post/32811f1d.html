<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.0"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Java简明笔记（三） 接口 - J.e</title><meta description="什么是接口假设有一种整数序列服务，这种服务可以计算前n个整数的平均值。就像这样： 1234public static double average(IntSequence seq, int n)&amp;amp;#123;  ...  return average&amp;amp;#125;  我们传入一个序列seq，以及我们想计算这个序列的前n个数，它返回平均数。 然而，这样的序列可以有很多种形式，比如用户给出的序列、随机数序"><meta property="og:type" content="blog"><meta property="og:title" content="Java简明笔记（三） 接口"><meta property="og:url" content="https://jerrysheh.me/post/32811f1d.html"><meta property="og:site_name" content="J.e"><meta property="og:description" content="什么是接口假设有一种整数序列服务，这种服务可以计算前n个整数的平均值。就像这样： 1234public static double average(IntSequence seq, int n)&amp;amp;#123;  ...  return average&amp;amp;#125;  我们传入一个序列seq，以及我们想计算这个序列的前n个数，它返回平均数。 然而，这样的序列可以有很多种形式，比如用户给出的序列、随机数序"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://jerrysheh.me/img/og_image.png"><meta property="article:published_time" content="2018-01-20T14:27:27.000Z"><meta property="article:modified_time" content="2020-03-06T15:24:30.770Z"><meta property="article:author" content="Jerry Sheh"><meta property="article:tag" content="Java"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://jerrysheh.me/post/32811f1d.html"},"headline":"J.e","image":["https://jerrysheh.me/img/og_image.png"],"datePublished":"2018-01-20T14:27:27.000Z","dateModified":"2020-03-06T15:24:30.770Z","author":{"@type":"Person","name":"Jerry Sheh"},"description":"什么是接口假设有一种整数序列服务，这种服务可以计算前n个整数的平均值。就像这样： 1234public static double average(IntSequence seq, int n)&amp;#123;  ...  return average&amp;#125;  我们传入一个序列seq，以及我们想计算这个序列的前n个数，它返回平均数。 然而，这样的序列可以有很多种形式，比如用户给出的序列、随机数序"}</script><link rel="canonical" href="https://jerrysheh.me/post/32811f1d.html"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.13.1/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><!--!--><!--!--><!--!--></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="J.e" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">时间线</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/about">关于</a><a class="navbar-item" href="/sentences">醍醐灌顶</a><a class="navbar-item" href="/anpu">Anpu</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2018-01-20T14:27:27.000Z" title="2018-01-20T14:27:27.000Z">2018-01-20</time><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a><span> / </span><a class="link-muted" href="/categories/Java/Java-SE/">Java SE</a></span><span class="level-item">22 分钟 读完 (大约 3345 个字)</span><span class="level-item" id="busuanzi_container_page_pv"><i class="far fa-eye"></i>&nbsp;&nbsp;<span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">Java简明笔记（三） 接口</h1><div class="content"><h1 id="什么是接口"><a href="#什么是接口" class="headerlink" title="什么是接口"></a>什么是接口</h1><p>假设有一种整数序列服务，这种服务可以计算前n个整数的平均值。就像这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">average</span><span class="params">(IntSequence seq, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> average</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们传入一个序列seq，以及我们想计算这个序列的前n个数，它返回平均数。</p>
<p>然而，这样的序列可以有很多种形式，比如用户给出的序列、随机数序列、素数序列、整数数组中的元素序列……</p>
<a id="more"></a>

<p>现在，我们想实现一种单一机制，来处理所有的这些序列。要做到这一点，就得考虑上面序列的共性。</p>
<p>不难知道，我们需要两个方法。</p>
<ol>
<li>判断是否还有下一个元素</li>
<li>获得下一个元素</li>
</ol>
<p>我们暂时不去想这两个方法具体怎么实现，只是知道需要有这两个方法。于是，我们的average计算平均数服务可以是这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">average</span><span class="params">(IntSequence seq, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (seq.hasNext() &amp;&amp; count &lt; n)&#123;</span><br><span class="line">    count ++;</span><br><span class="line">    sum += seq.next();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> count == <span class="number">0</span> ? <span class="number">0</span> : sum / count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Java中，我们把这两种方法声明出来，但不实现，这就是接口了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IntSequence</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>接口中所有的方法默认为public</li>
</ul>
<hr>
<h1 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h1><h2 id="一个实现"><a href="#一个实现" class="headerlink" title="一个实现"></a>一个实现</h2><p>现在有一个类，它的序列是一组无限平方数（0,1,4,9,16,25…），我们要用上面的average方法来计算这组平方数前n个数的平均值。那么，这个类必然有<code>hasNext()</code>和<code>next()</code>这两个方法的<code>具体实现</code>。我们就称这个类实现了上面的<code>IntSequence</code>接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SquareSequence</span> <span class="keyword">implements</span> <span class="title">IntSequence</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    i++;</span><br><span class="line">    <span class="keyword">return</span> i * i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获得前100个平方数的平均值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SquareSequence squares = <span class="keyword">new</span> SquareSequence();</span><br><span class="line"><span class="keyword">double</span> avg = average(squares, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p><code>squares</code>是<code>SquareSequence</code>类的一个对象，先new一个<code>squares</code>对象。然后在<code>average</code>方法中传入了这个对象作为序列，并且传入100表示前100个平方数。</p>
<h2 id="又一个实现"><a href="#又一个实现" class="headerlink" title="又一个实现"></a>又一个实现</h2><p>现在又有一个类，它是一个有限序列。是正整数从个位开始每个位的值。比如1729，那么序列就是9，2，7，1。这个序列必然也有<code>hasNext()</code>和<code>next()</code>这两个方法的<code>具体实现</code>。因此，这个类也实现了上面的<code>IntSequence</code>接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DigitSequence</span> <span class="keyword">implements</span> <span class="title">IntSequence</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DigitSequence</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    number = n;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> number !=<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = number % <span class="number">10</span>;</span><br><span class="line">    number /= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> number;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>计算1729位数序列的平均值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IntSequence digits = <span class="keyword">new</span> DigitSequence(<span class="number">1729</span>);</span><br><span class="line"><span class="keyword">double</span> avg = average(digits, <span class="number">100</span>);  <span class="comment">//虽然这里传入100，但实际只有4个数</span></span><br></pre></td></tr></table></figure>

<p>值得注意的是，<code>IntSequence接口</code>是<code>DigitSequence类</code>的父类，所以我们可以指定<code>digits变量</code>的类型为<code>IntSequence接口</code>类型。</p>
<hr>
<ul>
<li>从父类转换为子类，用<code>cast</code>。</li>
<li>你只能将一个对象强制转换为它的实际类或者它的父类之一。</li>
<li>可以用<code>instanceof</code>测试对象是否期望的类型</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果DigitSequence是sequence的父类，if语句为true</span></span><br><span class="line"><span class="keyword">if</span> (sequence <span class="keyword">instanceof</span> DigitSequence) &#123;</span><br><span class="line">  DigitSequence digits = (DigitSequence) sequence;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>一个接口可以继承(extend)另外一个接口，在原有方法上提供额外的方法。</li>
<li>一个类可以实现多个接口，用逗号隔开。</li>
<li>定义在接口中的任何变量自动为 <code>public static final</code>。</li>
</ul>
<hr>
<h1 id="接口中可以有哪些方法修饰符？"><a href="#接口中可以有哪些方法修饰符？" class="headerlink" title="接口中可以有哪些方法修饰符？"></a>接口中可以有哪些方法修饰符？</h1><p>Java8 的接口方法可以有如下方法定义：</p>
<p>public, abstract, default, static，strictfp</p>
<h2 id="public"><a href="#public" class="headerlink" title="public"></a>public</h2><p>接口中所有的方法都是<code>public</code>的，不可以是 protected 或者 private。</p>
<h2 id="接口中写-abstract-有什么意义？"><a href="#接口中写-abstract-有什么意义？" class="headerlink" title="接口中写 abstract 有什么意义？"></a>接口中写 abstract 有什么意义？</h2><p>其实接口中所有的方法都是 <code>public abstract</code> 的（静态方法除外），不写也默认是 abstract。只是可以省略而已。写了也不会错。</p>
<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>接口可以有静态方法（Java 8新特性），但必须提供实现。</p>
<h2 id="default-（默认方法）"><a href="#default-（默认方法）" class="headerlink" title="default （默认方法）"></a>default （默认方法）</h2><p>可以给接口一个默认实现（默认方法），用<code>default</code>修饰。（Java 8新特性）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IntSequence</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认方法的一个重要用途：<strong>接口演化</strong></p>
<p>有一个旧接口，一个类实现了这个接口。新版Java中对旧接口增加了一个方法，那么这个类就无法编译了，因为这个类没有实现新增加的方法。这时，如果新增加的方法设为默认方法。那么在类的实例中调用这个方法时，执行的是接口的默认方法，即使这个类没有该方法也得以编译和运行。</p>
<h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><ul>
<li>如果一个类实现了两个接口，其中一个接口有默认方法，另一个接口有同名同参数的方法（默认或非默认），那么编译器会报错。可以用<code>父类.super.方法()</code>来决定要执行哪个方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回 Identified 接口的 getID，而不是 Persons 接口的</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Persons</span>, <span class="title">Identified</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getID</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Identified.<span class="keyword">super</span>.getID();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="strictfp"><a href="#strictfp" class="headerlink" title="strictfp"></a>strictfp</h2><p>strictfp, 即 strict float point (精确浮点)，这个用得比较少，暂时不深入研究。</p>
<hr>
<h1 id="Java标准类库的几个常用接口"><a href="#Java标准类库的几个常用接口" class="headerlink" title="Java标准类库的几个常用接口"></a>Java标准类库的几个常用接口</h1><h2 id="Comparable接口"><a href="#Comparable接口" class="headerlink" title="Comparable接口"></a>Comparable接口</h2><p>如果一个类想启用对象排序，它应该实现 Comparable 接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T other)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>String类实现<code>Comparable&lt;String&gt;</code>，它的 compareTo 方法是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String other)</span></span></span><br></pre></td></tr></table></figure>

<p>Employee类实现<code>Comparable&lt;Employee&gt;</code>，它的compareTo方法可以这样写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Employee</span>&gt; </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Employee other)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getID() - other.getID();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回正整数（不一定是1），表示x应该在y后面；返回负整数（不一定是-1），表示x应该在y前面；返回0，说明相等。</p>
<ul>
<li>如果返回负整数，有可能溢出，导致结果变成一个大正整数，用<code>Interger.compare</code>方法解决。</li>
<li>比较浮点数时，应该用静态方法<code>Double.compare</code>，不能用两数之差。</li>
</ul>
<h3 id="实现了Comparable后，如何使用？"><a href="#实现了Comparable后，如何使用？" class="headerlink" title="实现了Comparable后，如何使用？"></a>实现了Comparable后，如何使用？</h3><p>我们的 Employee 类实现了 Comparable 接口，说明这个类的不同实例之间是可以比较的，比较的方法如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Employee s1 = <span class="keyword">new</span> Employee(<span class="number">18</span>,<span class="string">"Xiaoming"</span>);</span><br><span class="line">Employee s2 = <span class="keyword">new</span> Employee(<span class="number">20</span>,<span class="string">"Luohao"</span>);</span><br><span class="line">s1.compareTo(s2);</span><br></pre></td></tr></table></figure>

<p>可以将这些实例放到一个数组中，然后用<code>Arrays.sort()</code>进行排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个Employee数组</span></span><br><span class="line">Employee[] eArr = &#123;e1,e2,e3&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对Employee数组进行排序，如何排序？根据上面我们写的compareTo方法</span></span><br><span class="line">Arrays.sort(eArr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历输出</span></span><br><span class="line"><span class="keyword">for</span> (Employee ei:</span><br><span class="line">     eArr) &#123;</span><br><span class="line">    System.out.println(ei.getID());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Comparator接口"><a href="#Comparator接口" class="headerlink" title="Comparator接口"></a>Comparator接口</h2><p>我们比较字符串的时候，通常是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"hello"</span>;</span><br><span class="line">String s2 = <span class="string">"world"</span>;</span><br><span class="line">s1.compare(s2);</span><br></pre></td></tr></table></figure>

<p>这样会以首字母大小顺序对 s1,s2 进行比较。</p>
<p>但如果我们要比较的是字符串的长度，而不是根据首字母。就无法用Comparable接口的compareTo方法来实现。这时候就需要Comparator接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T first, T second)</span></span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以写一个类，叫<code>LenthComparator</code>，这个类实现了 <code>Comparator&lt;&gt;</code> 接口。 然后重写<code>compare</code>方法。</p>
<p>比较字符串长度的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LenthComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String first, String second)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> first.lenth() - second.lenth()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后对这个类进行实例化，再应用在两个字符串中，这样就实现了对字符串的长度的比较。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;String&gt; comp = <span class="keyword">new</span> LenthComparator();</span><br><span class="line"><span class="keyword">if</span> (comp.compare(words[i],words[j]) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这种调用是compare对象上的调用，而不是字符串自身。</p>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>当我们要对某个对象数组（比如student对象）进行排序的时候，不按comparable实现的比较方法来排序，而是要以另一种方式排序。这时候<code>Arrays.sort()</code>提供第二个参数，是一个 Comparator，意思是：以第二个参数（Comparator）制定的规则来对第一个参数（数组）进行排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">student[] sArr = &#123;s1,s2,s3&#125;;</span><br><span class="line">Arrays.sort(sArr, <span class="keyword">new</span> Comparator&lt;student&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(student o1, student o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.getAge() - o2.getAge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这样的代码比较啰嗦，我们可以用 lambda 表达式替代：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lambda 表达式会自动进行类型判断</span></span><br><span class="line">Arrays.sort(sArr, (o1,o2)-&gt;(o1.getAge() - o2.getAge()));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果你要比较的不是数组，而是一个集合，用<code>Collections.sort</code>代替<code>Arrays.sort</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种写法，IDEA会提示你可以用方法引用替代</span></span><br><span class="line">Collections.sort(studentList, ((o1, o2) -&gt; o1.getAge() - o2.getAge()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用方法引用，IDEA会提示你可以用 实例.sort 替代</span></span><br><span class="line">Collections.sort(studentList, Comparator.comparing(student::getAge));</span><br><span class="line"></span><br><span class="line"><span class="comment">// fine</span></span><br><span class="line">studentList.sort(Comparator.comparing(student::getAge));</span><br></pre></td></tr></table></figure>

<h3 id="继续扩展"><a href="#继续扩展" class="headerlink" title="继续扩展"></a>继续扩展</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按照名字进行排序</span></span><br><span class="line">Arrays.sort(arr, Comparator.comparing(Person::getName));</span><br><span class="line"></span><br><span class="line"><span class="comment">//按照名字长度进行排序</span></span><br><span class="line">Arrays.sort(arr,Comparator.comparing(Person::getName,(s,t)-&gt;Integer.compare(s.length(),t.length())));</span><br><span class="line">Arrays.sort(arr,Comparator.comparingInt(p-&gt;p.getName().length()));</span><br><span class="line"></span><br><span class="line"><span class="comment">//先按照名字进行排序,如果名字相同,再按照地址比较</span></span><br><span class="line">Arrays.sort(arr,Comparator.comparing(Person::getName).thenComparing(Person::getAddress));</span><br></pre></td></tr></table></figure>

<h2 id="Runable接口"><a href="#Runable接口" class="headerlink" title="Runable接口"></a>Runable接口</h2><p>Runable接口用来定义任务。比如我们想把特定的任务丢给一个单独的线程去做。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> run &#123;</span><br><span class="line">    <span class="comment">// how to run</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">Runnable task = <span class="keyword">new</span> HelloTask();</span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(task);</span><br><span class="line">thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，run方法就在一个单独的线程中去执行了，当前线程可以做别的事。</p>
<h2 id="Serializable-标记接口"><a href="#Serializable-标记接口" class="headerlink" title="Serializable 标记接口"></a>Serializable 标记接口</h2><h2 id="什么是序列化"><a href="#什么是序列化" class="headerlink" title="什么是序列化"></a>什么是序列化</h2><p>对象流是指将对象的内容进行流化。之后，我们就可以对流化后的对象进行读写操作或网络传输。序列化就是一种用来处理对象流的机制，为了解决在对对象流进行读写操作时所引发的问题。</p>
<h2 id="Serializable-接口的作用"><a href="#Serializable-接口的作用" class="headerlink" title="Serializable 接口的作用"></a>Serializable 接口的作用</h2><p>将需要被序列化的类实现 Serializable 接口，该接口没有需要实现的方法，<strong>implements Serializable 只是为了标注该对象是可被序列化的</strong>。</p>
<p>之后，使用一个输出流(如：FileOutputStream)来构造一个 ObjectOutputStream(对象流) 对象，接着，使用 ObjectOutputStream 对象的 writeObject(Object obj) 方法就可以将参数为obj的对象写出(即保存其状态)，要恢复的话则用输入流。</p>
<h2 id="UI回调"><a href="#UI回调" class="headerlink" title="UI回调"></a>UI回调</h2><p>在GUI中，当用户单击按钮、选择菜单项、拖动滑块等操作时，我们必须指定需要执行的行为。这种行为称为<code>回调</code>。</p>
<p>在Java GUI类库中，用接口来回调。如在JavaFX中，报告事件的接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EventHandler</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">handle</span> <span class="params">(T event)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个CancelAction类实现上面的接口，指定按钮单击事件的行为ActionEvent，然后创建该类的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CancelAction</span> <span class="keyword">implements</span> <span class="title">EventHandler</span>&lt;<span class="title">ActionEvent</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span> <span class="params">(ActionEvent event)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Oh shit!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Button cancelButton = <span class="keyword">new</span> Button(<span class="string">"Cancel!"</span>);</span><br><span class="line">cancelButton.setOnAction(<span class="keyword">new</span> CancelAction());</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="接口-Interface-和抽象类-abstract-class-的区别"><a href="#接口-Interface-和抽象类-abstract-class-的区别" class="headerlink" title="接口(Interface)和抽象类(abstract class)的区别"></a>接口(Interface)和抽象类(abstract class)的区别</h1><p>接口是对动作(行为)的抽象，表示的是”like-a”关系。</p>
<p>抽象类是对类的抽象，表示的是”is-a”关系。</p>
<p>接口注重的是方法，而抽象类注重属性和方法。</p>
<table>
<thead>
<tr>
<th>抽象类</th>
<th>接口</th>
</tr>
</thead>
<tbody><tr>
<td>可以有构造函数</td>
<td>没有构造函数</td>
</tr>
<tr>
<td>可以有普通成员变量</td>
<td>没有普通成员变量，只能有常量</td>
</tr>
<tr>
<td>可以有实现方法和抽象方法</td>
<td>有抽象方法，可以有静态方法（java8），如果方法被default修饰就可以实现（java8）</td>
</tr>
<tr>
<td>一个类只能继承一个抽象类</td>
<td>接口可以有多个实现</td>
</tr>
</tbody></table>
<h2 id="什么时候使用接口，什么时候使用抽象类"><a href="#什么时候使用接口，什么时候使用抽象类" class="headerlink" title="什么时候使用接口，什么时候使用抽象类"></a>什么时候使用接口，什么时候使用抽象类</h2><p>如果你想实现多继承，那么就用接口，Java不支持多继承，但是可以实现多个接口</p>
<p>接口主要用于模块与模块之间的调用</p>
<p>抽象类主要用于当做基础类使用，即基类</p>
<blockquote>
<p>举个简单的例子，飞机和鸟是不同类的事物，但是它们都有一个共性，就是都会飞。那么在设计的时候，可以将飞机设计为一个类Airplane，将鸟设计为一个类Bird，但是不能将 飞行 这个特性也设计为类，因此它只是一个行为特性，并不是对一类事物的抽象描述。此时可以将 飞行 设计为一个接口Fly，包含方法fly( )，然后Airplane和Bird分别根据自己的需要实现Fly这个接口。然后至于有不同种类的飞机，比如战斗机、民用飞机等直接继承Airplane即可，对于鸟也是类似的，不同种类的鸟直接继承Bird类即可。从这里可以看出，继承是一个 “是不是”的关系，而 接口 实现则是 “有没有”的关系。如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而接口实现则是有没有、具备不具备的关系，比如鸟是否能飞（或者是否具备飞行这个特点），能飞行则可以实现这个接口，不能飞行就不实现这个接口。 (<a href="https://www.cnblogs.com/NewDolphin/p/5397297.html">例子出处</a>)</p>
</blockquote>
</div><div class="article-tags size-small mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Java/">Java</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/post/4afa9fc3.html"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Android笔记（一） 初识</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/post/82216935.html"><span class="level-item">当你输入一个网址的时候，实际会发生什么?</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Jerry Sheh"></figure><p class="title is-size-4 is-block line-height-inherit">Jerry Sheh</p><p class="is-size-6 is-block">车顶上绑着飞机发动机</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Shenzhen</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">169</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">31</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">35</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="mailto:jerrysheh@gmail.com" target="_blank" rel="noopener">联系我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/Jerrysheh"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="email" href="mailto:jerrysheh@gmail.com"><i class="fa fa-envelope"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Zhihu" href="https://www.zhihu.com/people/jerrysheh"><i class="fab fa-zhihu"></i></a></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/Android/"><span class="level-start"><span class="level-item">Android</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/C-C/"><span class="level-start"><span class="level-item">C/C++</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Golang/"><span class="level-start"><span class="level-item">Golang</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">41</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/Java/Concurrent/"><span class="level-start"><span class="level-item">Concurrent</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Java/Effective-Java/"><span class="level-start"><span class="level-item">Effective Java</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Java/JDBC/"><span class="level-start"><span class="level-item">JDBC</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Java/JVM/"><span class="level-start"><span class="level-item">JVM</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Java/Java-SE/"><span class="level-start"><span class="level-item">Java SE</span></span><span class="level-end"><span class="level-item tag">20</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/Java-Web/"><span class="level-start"><span class="level-item">Java Web</span></span><span class="level-end"><span class="level-item tag">15</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/Java-Web/Spring/"><span class="level-start"><span class="level-item">Spring</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Java-Web/Web/"><span class="level-start"><span class="level-item">Web</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Java-Web/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"><span class="level-start"><span class="level-item">微服务</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Python/"><span class="level-start"><span class="level-item">Python</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"><span class="level-start"><span class="level-item">中间件</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/"><span class="level-start"><span class="level-item">redis</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/%E5%89%8D%E7%AB%AF/"><span class="level-start"><span class="level-item">前端</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"><span class="level-start"><span class="level-item">大数据</span></span><span class="level-end"><span class="level-item tag">12</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/Scala/"><span class="level-start"><span class="level-item">Scala</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/Spark/"><span class="level-start"><span class="level-item">Spark</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/hadoop/"><span class="level-start"><span class="level-item">hadoop</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%8A%80%E8%83%BD/"><span class="level-start"><span class="level-item">技能</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="level-start"><span class="level-item">操作系统</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="level-start"><span class="level-item">数据库</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">数据结构和算法</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%9E%8E%E6%8A%98%E8%85%BE/"><span class="level-start"><span class="level-item">瞎折腾</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E9%80%9F%E6%88%90%E8%AF%BE/"><span class="level-start"><span class="level-item">计算机科学速成课</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><span class="level-start"><span class="level-item">计算机网络</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="level-start"><span class="level-item">设计模式</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E8%AF%BB%E4%B9%A6%E4%B8%8E%E7%94%9F%E6%B4%BB/"><span class="level-start"><span class="level-item">读书与生活</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><div class="card widget" id="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="is-flex" href="#什么是接口"><span class="mr-2">1</span><span>什么是接口</span></a></li><li><a class="is-flex" href="#实现接口"><span class="mr-2">2</span><span>实现接口</span></a><ul class="menu-list"><li><a class="is-flex" href="#一个实现"><span class="mr-2">2.1</span><span>一个实现</span></a></li><li><a class="is-flex" href="#又一个实现"><span class="mr-2">2.2</span><span>又一个实现</span></a></li></ul></li><li><a class="is-flex" href="#接口中可以有哪些方法修饰符？"><span class="mr-2">3</span><span>接口中可以有哪些方法修饰符？</span></a><ul class="menu-list"><li><a class="is-flex" href="#public"><span class="mr-2">3.1</span><span>public</span></a></li><li><a class="is-flex" href="#接口中写-abstract-有什么意义？"><span class="mr-2">3.2</span><span>接口中写 abstract 有什么意义？</span></a></li><li><a class="is-flex" href="#static"><span class="mr-2">3.3</span><span>static</span></a></li><li><a class="is-flex" href="#default-（默认方法）"><span class="mr-2">3.4</span><span>default （默认方法）</span></a><ul class="menu-list"><li><a class="is-flex" href="#解决冲突"><span class="mr-2">3.4.1</span><span>解决冲突</span></a></li></ul></li><li><a class="is-flex" href="#strictfp"><span class="mr-2">3.5</span><span>strictfp</span></a></li></ul></li><li><a class="is-flex" href="#Java标准类库的几个常用接口"><span class="mr-2">4</span><span>Java标准类库的几个常用接口</span></a><ul class="menu-list"><li><a class="is-flex" href="#Comparable接口"><span class="mr-2">4.1</span><span>Comparable接口</span></a><ul class="menu-list"><li><a class="is-flex" href="#实现了Comparable后，如何使用？"><span class="mr-2">4.1.1</span><span>实现了Comparable后，如何使用？</span></a></li></ul></li><li><a class="is-flex" href="#Comparator接口"><span class="mr-2">4.2</span><span>Comparator接口</span></a><ul class="menu-list"><li><a class="is-flex" href="#扩展"><span class="mr-2">4.2.1</span><span>扩展</span></a></li><li><a class="is-flex" href="#继续扩展"><span class="mr-2">4.2.2</span><span>继续扩展</span></a></li></ul></li><li><a class="is-flex" href="#Runable接口"><span class="mr-2">4.3</span><span>Runable接口</span></a></li><li><a class="is-flex" href="#Serializable-标记接口"><span class="mr-2">4.4</span><span>Serializable 标记接口</span></a></li><li><a class="is-flex" href="#什么是序列化"><span class="mr-2">4.5</span><span>什么是序列化</span></a></li><li><a class="is-flex" href="#Serializable-接口的作用"><span class="mr-2">4.6</span><span>Serializable 接口的作用</span></a></li><li><a class="is-flex" href="#UI回调"><span class="mr-2">4.7</span><span>UI回调</span></a></li></ul></li><li><a class="is-flex" href="#接口-Interface-和抽象类-abstract-class-的区别"><span class="mr-2">5</span><span>接口(Interface)和抽象类(abstract class)的区别</span></a><ul class="menu-list"><li><a class="is-flex" href="#什么时候使用接口，什么时候使用抽象类"><span class="mr-2">5.1</span><span>什么时候使用接口，什么时候使用抽象类</span></a></li></ul></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">推荐链接</h3><ul class="menu-list"><li><a class="level is-mobile is-mobile" href="https://www.wmyskxz.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">我没有三颗心脏</span></span><span class="level-right"><span class="level-item tag">www.wmyskxz.com</span></span></a></li><li><a class="level is-mobile is-mobile" href="https://www.cnblogs.com/vamei/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Vamei</span></span><span class="level-right"><span class="level-item tag">www.cnblogs.com</span></span></a></li><li><a class="level is-mobile is-mobile" href="https://www.celesteheadlee.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">celesteheadlee</span></span><span class="level-right"><span class="level-item tag">www.celesteheadlee.com</span></span></a></li><li><a class="level is-mobile is-mobile" href="https://www.xaprb.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Baron Schwartz</span></span><span class="level-right"><span class="level-item tag">www.xaprb.com</span></span></a></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.png" alt="J.e" height="28"></a><p class="size-small"><span>&copy; 2020 Jerry Sheh</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'https://jerrysheh.me',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>