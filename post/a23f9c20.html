<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Java并发编程之并发工具 - J.e</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="J.e"><meta name="msapplication-TileImage" content="/images/blog/ava.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="J.e"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Java自带的平台类库（java.util.concurrent）里面包含了很多有用的工具，来帮助我们更好地处理并发问题。这一篇主要介绍一下几类工具：  atomic原子类：AtomicLong 同步容器类：Vector、Hashtable 并发容器类：concurrentHashMap、ConcurrentLinkedQueue、BlockingQueue（阻塞队列） 并发工具类：闭锁（Latc"><meta property="og:type" content="blog"><meta property="og:title" content="Java并发编程之并发工具"><meta property="og:url" content="https://jerrysheh.com/post/a23f9c20.html"><meta property="og:site_name" content="J.e"><meta property="og:description" content="Java自带的平台类库（java.util.concurrent）里面包含了很多有用的工具，来帮助我们更好地处理并发问题。这一篇主要介绍一下几类工具：  atomic原子类：AtomicLong 同步容器类：Vector、Hashtable 并发容器类：concurrentHashMap、ConcurrentLinkedQueue、BlockingQueue（阻塞队列） 并发工具类：闭锁（Latc"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://jerrysheh.com/images/Java/atomic.png"><meta property="og:image" content="https://jerrysheh.com/images/Java/concurrentHashMap.png"><meta property="og:image" content="https://jerrysheh.com/images/Java/blocking-queue.png"><meta property="article:published_time" content="2018-10-30T07:08:26.000Z"><meta property="article:modified_time" content="2021-04-21T14:51:17.954Z"><meta property="article:author" content="Jerry Sheh"><meta property="article:tag" content="并发"><meta property="article:tag" content="Java"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="../../../../images/Java/atomic.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://jerrysheh.com/post/a23f9c20.html"},"headline":"Java并发编程之并发工具","image":["https://jerrysheh.com/images/Java/atomic.png","https://jerrysheh.com/images/Java/concurrentHashMap.png","https://jerrysheh.com/images/Java/blocking-queue.png"],"datePublished":"2018-10-30T07:08:26.000Z","dateModified":"2021-04-21T14:51:17.954Z","author":{"@type":"Person","name":"Jerry Sheh"},"description":"Java自带的平台类库（java.util.concurrent）里面包含了很多有用的工具，来帮助我们更好地处理并发问题。这一篇主要介绍一下几类工具：  atomic原子类：AtomicLong 同步容器类：Vector、Hashtable 并发容器类：concurrentHashMap、ConcurrentLinkedQueue、BlockingQueue（阻塞队列） 并发工具类：闭锁（Latc"}</script><link rel="canonical" href="https://jerrysheh.com/post/a23f9c20.html"><link rel="icon" href="/images/blog/ava.png"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.13.1/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><!--!--><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/images/blog/logo.png" alt="J.e" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">时间线</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/about">关于</a><a class="navbar-item" href="/sentences">醍醐灌顶</a><a class="navbar-item" href="/anpu">Anpu</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2018-10-30T07:08:26.000Z" title="2018-10-30 15:08:26">2018-10-30</time>发表</span><span class="level-item"><time dateTime="2021-04-21T14:51:17.954Z" title="2021-4-21 22:51:17">2021-04-21</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a><span> / </span><a class="link-muted" href="/categories/Java/Concurrent/">Concurrent</a></span></div></div><h1 class="title is-3 is-size-4-mobile">Java并发编程之并发工具</h1><div class="content"><p>Java自带的平台类库（java.util.concurrent）里面包含了很多有用的工具，来帮助我们更好地处理并发问题。这一篇主要介绍一下几类工具：</p>
<ol>
<li><strong>atomic原子类</strong>：AtomicLong</li>
<li><strong>同步容器类</strong>：Vector、Hashtable</li>
<li><strong>并发容器类</strong>：concurrentHashMap、ConcurrentLinkedQueue、BlockingQueue（阻塞队列）</li>
<li><strong>并发工具类</strong>：闭锁（Latch）、栅栏（Barrier）、信号量（Semaphore）</li>
</ol>
<span id="more"></span>

<h1 id="atomic原子类"><a href="#atomic原子类" class="headerlink" title="atomic原子类"></a>atomic原子类</h1><h2 id="为什么要用atomic原子类"><a href="#为什么要用atomic原子类" class="headerlink" title="为什么要用atomic原子类"></a>为什么要用atomic原子类</h2><p>像 <code>i++</code> 这样的操作并不是原子操作，多线程访问可能出现问题，在 <a href="../post/b4ed848b.html">Java并发编程之安全性</a> 就提到可以用 <code>java.util.concurrent.atomic</code> 包的 atomic原子类 来将 <code>i++</code> 封装成原子操作。</p>
<p><img src="../../../../images/Java/atomic.png" alt="atomic"></p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>非阻塞并发算法。典型的算法有compare-and-swap（CAS），即一个线程在修改一个变量时，先将当前值（当前内存地址值）跟预期值进行比较，如果一致，则进行修改，如果不一致，说明这个变量被其他线程改了，就不进行修改。</p>
<p>但是 CAS 也不是完美的，比如经典的ABA问题：一个变量 V 初次读取的时候是 A值，之后被其他线程修改为 B，然后又修改为 A，那 CAS 会认为它从来没有变过。</p>
<p>参考：<a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-concurrency/compare-and-swap.html">http://tutorials.jenkov.com/java-concurrency/compare-and-swap.html</a></p>
<h2 id="原子类的更新问题"><a href="#原子类的更新问题" class="headerlink" title="原子类的更新问题"></a>原子类的更新问题</h2><p>用 Atomiclong 的 <code>incrementAndGet()</code> 方法或者 <code>set()</code> 方法更新值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Atomiclong count = <span class="keyword">new</span> AtomicLong(<span class="number">10</span>);</span><br><span class="line">count.incrementAndGet(); <span class="comment">// 11</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> value = <span class="number">2L</span>;</span><br><span class="line">count.set(value);  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>当 value 是一个方法的返回值时，如<code>Math.max(count.get(), observed)</code> (选择两者中比较大的)，这个操作也并不安全。</p>
<p>正确的做法是用<code>compareAndSet(old, new)</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    oldValue = count.get();</span><br><span class="line">    newValue = Math.max(count.get(), observed);</span><br><span class="line">&#125; <span class="keyword">while</span>(!count.compareAndSet(oldValue,newValue))</span><br></pre></td></tr></table></figure>

<p>在Java 8中，上述样板代码可以简化为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">count.updateAndGet(x-&gt;Math.max(count.get(), observed));</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line">count.accumulateAndGet(observed, Math::max);</span><br></pre></td></tr></table></figure>

<h2 id="用-LongAdder-优化高并发性能问题"><a href="#用-LongAdder-优化高并发性能问题" class="headerlink" title="用 LongAdder 优化高并发性能问题"></a>用 LongAdder 优化高并发性能问题</h2><p>如果在高并发情况下 Atomiclong 的 CAS 乐观锁需要太多次重试，这会带来一定的性能下降。Java 8 提供了 LongAdder 类。其思想跟JDK 1.7的 concurrenthashmap类似，采用分段的思想。LongAdder 内部包含多个值，每个线程只更新其中的一个，然后返回所有值的和。</p>
<p>LongAdder 适用于统计求和计数的场景，例如计算qps。在高并发场景下，qps这个值会被多个线程频繁更新的，所以 LongAdder 很适合。但 LongAdder 并不能替代 Atomiclong。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> LongAdder adder = <span class="keyword">new</span> LongAdder();</span><br><span class="line"><span class="comment">// thread 1</span></span><br><span class="line">adder.increment();</span><br><span class="line"></span><br><span class="line"><span class="comment">// thread 2</span></span><br><span class="line">adder.increment();</span><br><span class="line"></span><br><span class="line"><span class="comment">// main thread</span></span><br><span class="line">adder.sum();</span><br></pre></td></tr></table></figure>

<p>LongAccumulator 将这种思想推广到任意的累加操作，而不仅仅是+1</p>
<hr>
<h1 id="同步容器类"><a href="#同步容器类" class="headerlink" title="同步容器类"></a>同步容器类</h1><p>同步容器类包括 Vector 和 Hashtable。</p>
<p>它们实现线程安全的方式十分简单粗暴：<strong>对每个公有方法进行同步，使得每次只有一个线程能够访问容器的状态</strong>。这种线程安全方式对于容器自身来说是安全的，但在调用方可能会出现问题，因此使用时要注意调用方可能需要做一些额外的协调。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 Vector 最后一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getLast</span><span class="params">(Vector list)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> lastIndex = list.size() - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> list.get(lastIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除 Vector 最后一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteLast</span><span class="params">(Vector list)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> lastIndex = list.size() - <span class="number">1</span>;</span><br><span class="line">  list.remove(lastIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从 Vector 的角度，无论你用多少个线程调用多少次<code>deleteLast()</code>方法，都不会让 Vector 内部出问题。然而，从调用者的角度，线程A调用getLast，线程A先观察到size为10，然后时间片切换到线程B调用deleteLast，B也观察到size为10，然后B删除了最后一个元素，然后A获取最后一个元素，发现这个元素不存在，于是抛出<code>ArrayIndexOutOfBoundsException</code>。</p>
<p>另一个例子是，用一个 for 循环迭代 Vector，循环到一半时，另一个线程删除了后面某些元素，迭代到后面时就会找不到元素抛出<code>ArrayIndexOutOfBoundsException</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果迭代到一半，另一个线程删除了后面的元素，导致 get(i) 取不到</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; vector.size() ;i++ ) &#123;</span><br><span class="line">  doSomething(vector.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们通常会用 Iterator 可以对集合进行遍历，但是却 <strong>不能在遍历过程对原集合做增、删、改</strong>，会抛出 <code>ConcurrentModificationException</code>。这是 Java 的一种并发预警警示器，叫 fail-fast。告知我们集合在遍历过程中被修改了。</p>
<p>有时候，我们看起来好像没有迭代，但仍然抛出了<code>ConcurrentModificationException</code>。是因为有些方法隐式地进行了迭代，如打印一个Hashset，事实上会调用 toString 方法，这个方法不断调用 StringBuilder.append 把各个元素转为字符串，这其实就是迭代了。同理，hashCode方法、equals方法、containAll、removeAll、retainAll等方法都是如此。</p>
<p><font color="red">因此，使用同步容器类时，需要在调用方加 synchronized 同步。</font></p>
<hr>
<h1 id="并发容器类"><a href="#并发容器类" class="headerlink" title="并发容器类"></a>并发容器类</h1><p>同步容器简单粗暴地对公有方法加同步，实际上是强行将对容器状态的访问串行化了，这对并发性能带来了很大影响。在 Java 5 之后，增加了如 ConcurrentHashMap、ConcurrentLinkedQueue 这样的并发容器，天生为并发程序设计。<strong>在多线程中应该尽可能用并发容器，而不是同步容器</strong>。</p>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p>ConcurrentHashMap 采用了细粒度的加锁机制，称为分段锁（Lock Striping）。分段锁的原理是，容器内部有多个锁，每一把锁只锁住容器内一部分数据。在 JDK 1.7 里，一个 ConcurrentHashMap 内部是一个 Segment 数组， Segment 数组每个元素都是一个 Entry 数组，Entry 数组每个元素都是 Entry 链表对象。加锁时，不是加锁整个 ConcurrentHashMap，而是加锁 Segment 数组上的每个 Segment 对象。</p>
<p><img src="../../../../images/Java/concurrentHashMap.png" alt="concurrentHashMap"></p>
<p><strong>但是在JDK 1.8中，取消了基于 Segment 的分段锁思想，改用 CAS + synchronized 控制并发操作</strong>。</p>
<p>ConcurrentHashMap 迭代时不会抛出 <code>ConcurrentModificationException</code>，是 fail-safe 的。它实现了 ConcurrentMap 接口，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConcurrentMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 仅当 K 没有相应的映射值时才插入</span></span><br><span class="line">    <span class="function">V <span class="title">putIfAbsent</span><span class="params">(K key, V value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 仅当 K 被映射到 value 时才插入</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key, Object value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 仅当 K 被映射到 oldValue 时才替换为 newValue</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">replace</span><span class="params">(K key, V oldValue, V newValue)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 仅当 K 被映射到某个值时才替换为 newValue</span></span><br><span class="line">    <span class="function">V <span class="title">replace</span><span class="params">(K key, V value)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>concurrentHashMap有两个带参构造器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// initialCapacity - 初始容量（默认16）</span></span><br><span class="line">concurrentHashMap&lt;K, V&gt;(<span class="keyword">int</span> initialCapacity);</span><br><span class="line"></span><br><span class="line"><span class="comment">// loadactor - 如果每一个桶的平均负载超过这个值，会重新调整大小（默认0.75）</span></span><br><span class="line"><span class="comment">// concurrencyLevel - 并发写线程的估计数</span></span><br><span class="line">concurrentHashMap&lt;K, V&gt;(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadactor, <span class="keyword">int</span> concurrencyLevel)</span><br></pre></td></tr></table></figure>

<h3 id="使用-concurrentHashMap-做词频统计的例子"><a href="#使用-concurrentHashMap-做词频统计的例子" class="headerlink" title="使用 concurrentHashMap 做词频统计的例子"></a>使用 concurrentHashMap 做词频统计的例子</h3><p>考虑下面的例子，我们需要在每次访问时将 map 里面的值+1，虽然 concurrentHashMap 内部是线程安全的，但是这段代码并非线程安全，另一个线程可能也正在更新数值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentHashMap&lt;String,Long&gt; map = <span class="keyword">new</span> ConcurrentHashMap();</span><br><span class="line"><span class="keyword">long</span> oldValue = map.get(word);</span><br><span class="line"><span class="keyword">long</span> newValue = oldValue == <span class="keyword">null</span> ? <span class="number">1</span> : oldValue+<span class="number">1</span>;</span><br><span class="line">map.put(word, newValue);</span><br></pre></td></tr></table></figure>

<p>一般的改进如下，用到了CAS的思想，使用 replace 方法，如果替换不成功就不断尝试。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    oldValue = map.get(word);</span><br><span class="line">    newValue = oldValue == <span class="keyword">null</span> ? <span class="number">1</span> : oldValue+<span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (!map.replace(word, oldValue, newValue));</span><br></pre></td></tr></table></figure>

<p>但是我们太讨厌这样的样板代码了，进一步改进如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把 Long 换成了 LongAdder</span></span><br><span class="line">ConcurrentHashMap&lt;String,LongAdder&gt; map = <span class="keyword">new</span> ConcurrentHashMap();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果为空，新建</span></span><br><span class="line">map.putIfAbsent(word, <span class="keyword">new</span> LongAdder());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取再+1，实际上是把 do while 封装到 increment() 里面</span></span><br><span class="line">map.get(word).increment();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面两句可以合并为一句</span></span><br><span class="line">map.putIfAbsent(word, <span class="keyword">new</span> LongAdder()).increment();</span><br></pre></td></tr></table></figure>

<p>但如果我不是想 +1，而想做其他计算，就无法用 <code>increment()</code> 了。Java 8 中，compute 方法传入一个 key 和一个计算新值的函数，用于完成原子更新，推荐使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.compute(word, (k,v)-&gt; v == <span class="keyword">null</span>? <span class="number">1</span>:v+<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><p>这是一个写入时复制（Copy-On-Write）并发容器，用于替代SynchronizedList。在每次修改时，都会创建并重新发布一个新的容器副本。迭代器不会抛出<code>ConcurrentModificationException</code>，是 fail-safe 的。当迭代操作远远多于修改操作时，应该考虑使用Copy-On-Write容器。例如事件监听系统，接收事件通知的操作远远多于注册或注销监听器的操作。</p>
<p>类似的，有<code>CopyOnWriteArraySet</code>。</p>
<h2 id="BlockingQueue（生产者消费者模式）"><a href="#BlockingQueue（生产者消费者模式）" class="headerlink" title="BlockingQueue（生产者消费者模式）"></a>BlockingQueue（生产者消费者模式）</h2><p>BlockingQueue 是一个阻塞队列接口。其 put 方法将一个元素放进队列头端，如果队列已满，就一直阻塞，直到队列空出位置。同理，take 方法将从队列尾端取出一个元素，如果队列未空，就一直阻塞，直到队列有元素。</p>
<p><img src="../../../../images/Java/blocking-queue.png" alt="blocking-queue"></p>
<p>BlockingQueue非常适合用来做生产者-消费者模式。其优点是，将生产数据的过程与使用数据的过程解耦。</p>
<p>BlockingQueue 也提供了一个 offer 方法，如果数据不能添加进队列，返回一个失败状态。offer 方法可以带时间参数，表示在一段时间内尝试添加元素。poll 同理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> success = queue.offer(x, <span class="number">100</span>, TimeUnit.MILLSECONDS);</span><br></pre></td></tr></table></figure>

<p>BlockingQueue 的实现类有 LinkedBlockingQueue 和 ArrayBlockingQueue，以及按优先级排序的 PriorityBlockingQueue。还有一个比较特殊的 SynchronousQueue，它没有存储空间，只是维护一组线程。例如，一个线程 put 会被阻塞，直到另一个线程 take，才算成功交付。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>正常动作</th>
<th>特殊情况动作</th>
</tr>
</thead>
<tbody><tr>
<td>add</td>
<td>添加元素</td>
<td>队列满抛出 IllegalStateException</td>
</tr>
<tr>
<td>offer</td>
<td>添加元素并返回true</td>
<td>队列满返回false</td>
</tr>
<tr>
<td>put</td>
<td>添加元素</td>
<td>队列满阻塞</td>
</tr>
<tr>
<td>element</td>
<td>返回队列头元素</td>
<td>队列空抛出NoSuchElementException</td>
</tr>
<tr>
<td>peek</td>
<td>返回队列的头元素</td>
<td>队列空返回null</td>
</tr>
<tr>
<td>poll</td>
<td>移出并返回队列头元素</td>
<td>队列空返回null</td>
</tr>
<tr>
<td>remove</td>
<td>移出并返回队列头元素</td>
<td>队列空抛出NoSuchElementException</td>
</tr>
<tr>
<td>take</td>
<td>移出并返回队列头元素</td>
<td>队列空阻塞</td>
</tr>
</tbody></table>
<hr>
<h1 id="同步工具类"><a href="#同步工具类" class="headerlink" title="同步工具类"></a>同步工具类</h1><p>BlockingQueue 阻塞队列不仅能作为保存对象的容器，而且能根据其自身的状态来协调线程的控制流。所以它既是并发容器，也是一个同步工具。我们把能 <strong>根据其自身的状态来协调线程的控制流的工具称为同步工具</strong>。</p>
<p>同步工具类的特点是：封装了一些状态，这些状态决定执行同步工具类的线程是继续执行还是等待，此外还提供一些方法对状态进行操作。常见的同步工具类有：闭锁（Latch）、栅栏（Barrier）、信号量（Semaphore）。</p>
<h2 id="闭锁（Latch）"><a href="#闭锁（Latch）" class="headerlink" title="闭锁（Latch）"></a>闭锁（Latch）</h2><p>闭锁相当于一个门，且有一个开门的条件。未开门前，所有线程都不能通过，当门打开后才允许所有线程通过。闭锁打开之后将不能再关上。使用闭锁的场景有：</p>
<ul>
<li>确保某个计算在其需要的所有资源都被初始化后才继续执行。</li>
<li>确保某个服务在其依赖的其他服务都被启动之后才启动。</li>
<li>等待某个操作的参与者都就绪再继续执行（多人在线游戏）。</li>
</ul>
<p>CountDownLatch 是一种闭锁的实现。包括一个计数器，一开始为正数，表示需要等待的事件数量。以及 countDown 方法，每当一个等待的事件发生了，计数器就减一。直到为零闭锁打开。如果计数器不为零，那 await 会一直阻塞直到计数器为零，或者等待中的线程中断，或者等待超时。</p>
<h2 id="栅栏（Barrier）"><a href="#栅栏（Barrier）" class="headerlink" title="栅栏（Barrier）"></a>栅栏（Barrier）</h2><p>栅栏跟闭锁类似，不同点在于，所有线程必须同时到达栅栏位置，才能继续执行。<strong>闭锁用于等待事件，而栅栏用于等待其他线程</strong>，当所有线程到达 <code>barrier.await();</code> 的位置，栅栏放开。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// param 1 参与的线程数量 ， param 2 栅栏放开后执行的 runnable</span></span><br><span class="line">CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>, myRunnable);</span><br></pre></td></tr></table></figure>

<p>CyclicBarrier 与 CountDownLatch 的区别在于 CyclicBarrier 是可以重用的。 CyclicBarrier 可以使一定数据的参与方反复地在栅栏位置汇集，通常用于并行迭代算法。</p>
<h2 id="信号量（Semaphore）"><a href="#信号量（Semaphore）" class="headerlink" title="信号量（Semaphore）"></a>信号量（Semaphore）</h2><p>计数信号量（Counting Semaphore）用来控制同时访问某个特定资源的操作数量，或者同时执行某个指定操作的数量。</p>
<p>Semaphore 与 CountDownLatch 的区别在于 Semaphore 的计数器减少之后，还可以再增加，表示可用的资源数量。Semaphore 可以用来实现资源池，如数据库连接池。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//资源被使用代码</span></span><br><span class="line"></span><br><span class="line">semaphore.acquire(); <span class="comment">// 资源被获取</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 资源使用完毕代码</span></span><br><span class="line"></span><br><span class="line">semaphore.release(); <span class="comment">// 资源被释放</span></span><br></pre></td></tr></table></figure>

<h2 id="显式锁"><a href="#显式锁" class="headerlink" title="显式锁"></a>显式锁</h2><h3 id="可重入锁（ReentrantLock）"><a href="#可重入锁（ReentrantLock）" class="headerlink" title="可重入锁（ReentrantLock）"></a>可重入锁（ReentrantLock）</h3><p>ReentrantLock 是 Lock 接口的默认实现。实现了锁的基本功能。作用跟 <code>Synchronized</code> 一样，都是用于线程同步的。但 ReentrantLock 多了三个高级特性：</p>
<ol>
<li><strong>等待可中断</strong>：如果持有锁的线程长期不释放锁，正在等待的线程可以放弃等待，改为处理别的事情。</li>
<li><strong>可实现公平锁</strong>：公平锁是指按照申请锁的时间顺序依次获得锁，而非随机获得。可以通过带 boolean 值的构造函数要求使用公平锁。</li>
<li><strong>锁可以绑定多个条件</strong>：一个 ReentrantLock对象可以绑定多个 Condition 对象。</li>
</ol>
<h3 id="可重入读写锁（ReentrantReadWriteLock）"><a href="#可重入读写锁（ReentrantReadWriteLock）" class="headerlink" title="可重入读写锁（ReentrantReadWriteLock）"></a>可重入读写锁（ReentrantReadWriteLock）</h3><p>ReentrantReadWriteLock 是 ReadWriteLock 接口的默认实现。实际上是结合了可重入锁和读写锁的特性。内部维护了两个锁，ReadLock 和 WriteLock，其中<br>ReadLock 是线程共享的，而 WriteLock 是独占的。</p>
<p>可重入读写锁有一个小弊端，就是在“写”操作的时候，其它线程不能写也不能读。我们称这种现象为“写饥饿”。</p>
<h3 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h3><p>StampedLock 是 JDK 1.8 才发布的，作者依然是 Doug Lea。功能跟 ReentrantReadWriteLock 一样，但是性能更高，且不会发现写饥饿。其原理是，<strong>在读的时候如果发生了写，应该通过重试的方式来获取新的值，而不应该阻塞写操作。这种模式也就是典型的无锁编程思想，和CAS自旋的思想一样</strong>。这种操作方式决定了StampedLock在读线程非常多而写线程非常少的场景下非常适用，同时还避免了写饥饿情况的发生。</p>
<p>StampedLock的性能非常优异，基本上可以取代ReentrantReadWriteLock的作用。</p>
<hr>
<p>参考：</p>
<ul>
<li>《Java并发编程实战》</li>
<li><a target="_blank" rel="noopener" href="http://concurrent.redspider.group/article/03/14.html">第十四章 锁接口和类</a></li>
</ul>
</div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E5%B9%B6%E5%8F%91/">并发</a><a class="link-muted mr-2" rel="tag" href="/tags/Java/">Java</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/post/cf93e9b3.html"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Spring（八）SpringBoot 集成 JPA</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/post/3bdfeb29.html"><span class="level-item">聊聊并发和并发模型</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/images/blog/ava.png" alt="Jerry Sheh"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Jerry Sheh</p><p class="is-size-6 is-block">车顶上绑着飞机发动机</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Shenzhen</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">178</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">31</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">35</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="mailto:jerrysheh@gmail.com" target="_blank" rel="noopener">联系我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/Jerrysheh"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="email" href="mailto:jerrysheh@gmail.com"><i class="fa fa-envelope"></i></a></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Android/"><span class="level-start"><span class="level-item">Android</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/categories/C-C/"><span class="level-start"><span class="level-item">C/C++</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Golang/"><span class="level-start"><span class="level-item">Golang</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">43</span></span></a><ul><li><a class="level is-mobile" href="/categories/Java/Concurrent/"><span class="level-start"><span class="level-item">Concurrent</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/Java/Effective-Java/"><span class="level-start"><span class="level-item">Effective Java</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/Java/JDBC/"><span class="level-start"><span class="level-item">JDBC</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Java/JVM/"><span class="level-start"><span class="level-item">JVM</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/Java/Java-SE/"><span class="level-start"><span class="level-item">Java SE</span></span><span class="level-end"><span class="level-item tag">20</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Java-Web/"><span class="level-start"><span class="level-item">Java Web</span></span><span class="level-end"><span class="level-item tag">15</span></span></a><ul><li><a class="level is-mobile" href="/categories/Java-Web/Spring/"><span class="level-start"><span class="level-item">Spring</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/Java-Web/Web/"><span class="level-start"><span class="level-item">Web</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/Java-Web/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"><span class="level-start"><span class="level-item">微服务</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/"><span class="level-start"><span class="level-item">Python</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"><span class="level-start"><span class="level-item">中间件</span></span><span class="level-end"><span class="level-item tag">2</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/"><span class="level-start"><span class="level-item">redis</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E5%89%8D%E7%AB%AF/"><span class="level-start"><span class="level-item">前端</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"><span class="level-start"><span class="level-item">大数据</span></span><span class="level-end"><span class="level-item tag">12</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/Scala/"><span class="level-start"><span class="level-item">Scala</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/Spark/"><span class="level-start"><span class="level-item">Spark</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/hadoop/"><span class="level-start"><span class="level-item">hadoop</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E6%8A%80%E8%83%BD/"><span class="level-start"><span class="level-item">技能</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="level-start"><span class="level-item">操作系统</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="level-start"><span class="level-item">数据库</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">数据结构和算法</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%9E%8E%E6%8A%98%E8%85%BE/"><span class="level-start"><span class="level-item">瞎折腾</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E9%80%9F%E6%88%90%E8%AF%BE/"><span class="level-start"><span class="level-item">计算机科学速成课</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><span class="level-start"><span class="level-item">计算机网络</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="level-start"><span class="level-item">设计模式</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BB%E4%B9%A6%E4%B8%8E%E7%94%9F%E6%B4%BB/"><span class="level-start"><span class="level-item">读书与生活</span></span><span class="level-end"><span class="level-item tag">14</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#atomic原子类"><span class="level-left"><span class="level-item">1</span><span class="level-item">atomic原子类</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#为什么要用atomic原子类"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">为什么要用atomic原子类</span></span></a></li><li><a class="level is-mobile" href="#原理"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">原理</span></span></a></li><li><a class="level is-mobile" href="#原子类的更新问题"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">原子类的更新问题</span></span></a></li><li><a class="level is-mobile" href="#用-LongAdder-优化高并发性能问题"><span class="level-left"><span class="level-item">1.4</span><span class="level-item">用 LongAdder 优化高并发性能问题</span></span></a></li></ul></li><li><a class="level is-mobile" href="#同步容器类"><span class="level-left"><span class="level-item">2</span><span class="level-item">同步容器类</span></span></a></li><li><a class="level is-mobile" href="#并发容器类"><span class="level-left"><span class="level-item">3</span><span class="level-item">并发容器类</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#ConcurrentHashMap"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">ConcurrentHashMap</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#使用-concurrentHashMap-做词频统计的例子"><span class="level-left"><span class="level-item">3.1.1</span><span class="level-item">使用 concurrentHashMap 做词频统计的例子</span></span></a></li></ul></li><li><a class="level is-mobile" href="#CopyOnWriteArrayList"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">CopyOnWriteArrayList</span></span></a></li><li><a class="level is-mobile" href="#BlockingQueue（生产者消费者模式）"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">BlockingQueue（生产者消费者模式）</span></span></a></li></ul></li><li><a class="level is-mobile" href="#同步工具类"><span class="level-left"><span class="level-item">4</span><span class="level-item">同步工具类</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#闭锁（Latch）"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">闭锁（Latch）</span></span></a></li><li><a class="level is-mobile" href="#栅栏（Barrier）"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">栅栏（Barrier）</span></span></a></li><li><a class="level is-mobile" href="#信号量（Semaphore）"><span class="level-left"><span class="level-item">4.3</span><span class="level-item">信号量（Semaphore）</span></span></a></li><li><a class="level is-mobile" href="#显式锁"><span class="level-left"><span class="level-item">4.4</span><span class="level-item">显式锁</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#可重入锁（ReentrantLock）"><span class="level-left"><span class="level-item">4.4.1</span><span class="level-item">可重入锁（ReentrantLock）</span></span></a></li><li><a class="level is-mobile" href="#可重入读写锁（ReentrantReadWriteLock）"><span class="level-left"><span class="level-item">4.4.2</span><span class="level-item">可重入读写锁（ReentrantReadWriteLock）</span></span></a></li><li><a class="level is-mobile" href="#StampedLock"><span class="level-left"><span class="level-item">4.4.3</span><span class="level-item">StampedLock</span></span></a></li></ul></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">推荐链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://www.wmyskxz.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">我没有三颗心脏</span></span><span class="level-right"><span class="level-item tag">www.wmyskxz.com</span></span></a></li><li><a class="level is-mobile" href="https://www.cnblogs.com/vamei/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Vamei</span></span><span class="level-right"><span class="level-item tag">www.cnblogs.com</span></span></a></li><li><a class="level is-mobile" href="https://www.celesteheadlee.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">celesteheadlee</span></span><span class="level-right"><span class="level-item tag">www.celesteheadlee.com</span></span></a></li><li><a class="level is-mobile" href="https://www.xaprb.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Baron Schwartz</span></span><span class="level-right"><span class="level-item tag">www.xaprb.com</span></span></a></li><li><a class="level is-mobile" href="http://tutorials.jenkov.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">jenkov</span></span><span class="level-right"><span class="level-item tag">tutorials.jenkov.com</span></span></a></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/images/blog/logo.png" alt="J.e" height="28"></a><p class="is-size-7"><span>&copy; 2021 Jerry Sheh</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>